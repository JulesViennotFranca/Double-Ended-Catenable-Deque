From Coq Require Import ssreflect.
From Coq Require Import Program List ZArith Lia.
Import ListNotations.
From Equations Require Import Equations.
From Hammer Require Import Tactics.

From Deque Require Import ncdeque.

(* Types *)

Inductive vector (A : Type) : nat -> Type := 
| V0 {n : nat} : vector A n
| V1 {n : nat} : A -> vector A (1 + n)
| V2 {n : nat} : A -> A -> vector A (2 + n)
| V3 {n : nat} : A -> A -> A -> vector A (3 + n)
| V4 {n : nat} : A -> A -> A -> A -> vector A (4 + n)
| V5 {n : nat} : A -> A -> A -> A -> A -> vector A (5 + n)
| V6 {n : nat} : A -> A -> A -> A -> A -> A -> vector A (6 + n).
Arguments V0 {A n}.
Arguments V1 {A n}.
Arguments V2 {A n}.
Arguments V3 {A n}.
Arguments V4 {A n}.
Arguments V5 {A n}.
Arguments V6 {A n}.

Inductive t (A : Type) (q : nat) : Type :=
| Buffer : deque A q -> t A q.
Arguments Buffer {A q}.

Definition pt (A : Type) (increment : nat) (quantity : nat) := 
    t A (increment + Nat.iter increment Nat.pred quantity).

    (* Equivaut Ã  max increment quantity. *)

(* Models *)

Set Equations Transparent.

Equations seq {A q} : t A q -> list A :=
seq (Buffer d) := deque_seq d.

Equations vector_seq {A n} : vector A n -> list A :=
vector_seq V0 := [];
vector_seq (V1 a) := [a];
vector_seq (V2 a b) := [a] ++ [b];
vector_seq (V3 a b c) := [a] ++ [b] ++ [c];
vector_seq (V4 a b c d) := [a] ++ [b] ++ [c] ++ [d];
vector_seq (V5 a b c d e) := [a] ++ [b] ++ [c] ++ [d] ++ [e];
vector_seq (V6 a b c d e f) := [a] ++ [b] ++ [c] ++ [d] ++ [e] ++ [f].

Unset Equations Transparent.

(* Sequence mappings *)

Definition map_buffer {T : Type -> nat -> Type} {A : Type}
  (f : forall {lvl : nat}, T A lvl -> list A)
  {lvl q : nat}
  (b : t (T A lvl) q) : list A :=
  match b with 
  | Buffer d => map_deque (@f) d
  end.

Lemma correct_mapping {T : Type -> nat -> Type} {A : Type}
  (f : forall {lvl : nat}, T A lvl -> list A)
  {lvl q : nat}
  (b : t (T A lvl) q) :
  map_buffer (@f) b = concat (map f (seq b)).
Proof. destruct b; cbn; apply ncdeque.correct_mapping. Qed.

(* Lemmas *)

Lemma empty_buffer [A] (b : t A 0) : seq b = [].
Proof.
  dependent elimination b; simp seq;
  apply length_zero_iff_nil;
  rewrite deque_size; reflexivity.
Qed.

Equations length_app_last [A : Type] (a : A) (l : list A) : length (l ++ [a]) = S (length l) :=
length_app_last _ [] := eq_refl;
length_app_last a (b :: l) := f_equal S (length_app_last a l).

Opaque app.
Definition singleton {A : Type} (a1 : A) : list A := [a1].
Opaque singleton.

(* A list of tactics to be used when trying to resolve obligations generated by
   Equations. *)

#[export] Hint Rewrite <-app_assoc : rlist.
#[export] Hint Rewrite <-app_comm_cons : rlist.
#[export] Hint Rewrite app_nil_r : rlist.
#[export] Hint Rewrite length_app_last : rlist.

#[local] Obligation Tactic :=
  try first [ done | cbn; hauto db:rlist ].

(* Elements *)

Equations empty {A : Type} : { b : t A 0 | seq b = [] } :=
empty with ncdeque.empty => { | ? d := ? Buffer d }.

(* Functions *)

Equations vector_length {A n} (v : vector A n) : nat :=
vector_length V0 := 0;
vector_length (V1 _) := 1;
vector_length (V2 _ _) := 2;
vector_length (V3 _ _ _) := 3;
vector_length (V4 _ _ _ _) := 4;
vector_length (V5 _ _ _ _ _) := 5;
vector_length (V6 _ _ _ _ _ _) := 6.
Transparent vector_length.

Equations vector_fold_right {A B n} (fn : A -> B -> B) (v : vector A n) (init : B) :
   { res : B | res = List.fold_right fn init (vector_seq v) } :=
vector_fold_right fn V0 init := ? init;
vector_fold_right fn (V1 a) init := ? fn a init;
vector_fold_right fn (V2 a b) init := ? fn a (fn b init);
vector_fold_right fn (V3 a b c) init := ? fn a (fn b (fn c init));
vector_fold_right fn (V4 a b c d) init := ? fn a (fn b (fn c (fn d init)));
vector_fold_right fn (V5 a b c d e) init := ? fn a (fn b (fn c (fn d (fn e init))));
vector_fold_right fn (V6 a b c d e f) init := ? fn a (fn b (fn c (fn d (fn e (fn f init))))).

Equations vector_fold_left {A B n} (fn : B -> A -> B) (init : B) (v : vector A n) :
    { res : B | res = List.fold_left fn (vector_seq v) init } :=
vector_fold_left fn init V0 := ? init;
vector_fold_left fn init (V1 a) := ? fn init a;
vector_fold_left fn init (V2 a b) := ? fn (fn init a) b;
vector_fold_left fn init (V3 a b c) := ? fn (fn (fn init a) b) c;
vector_fold_left fn init (V4 a b c d) := ? fn (fn (fn (fn init a) b) c) d;
vector_fold_left fn init (V5 a b c d e) := ? fn (fn (fn (fn (fn init a) b) c) d) e;
vector_fold_left fn init (V6 a b c d e f) := ? fn (fn (fn (fn (fn (fn init a) b) c) d) e) f.

Equations translate {A q1 q2} (b : t A q1) (eq: q1 = q2) : { b' : t A q2 | seq b' = seq b } :=
translate b eq with comp_eq eq => { | eq_refl := ? b }.

Equations push {A q} (a1 : A) (b : t A q) : { b' : t A (S q) | seq b' = [a1] ++ seq b } :=
push a1 (Buffer d) with ncdeque.push a1 d => {
  | ? d' := ? Buffer d' }.

Equations inject {A q} (b : t A q) (a1 : A) : { b' : t A (S q) | seq b' = seq b ++ [a1] } :=
inject (Buffer d) a1 with ncdeque.inject d a1 => {
  | ? d' := ? Buffer d' }.

Equations pop {A q} (b : t A (S q)) : { '(a1, b') : A * t A q | [a1] ++ seq b' = seq b } :=
pop (Buffer d) with ncdeque.pop d => { | ? (a1, d') := ? (a1, Buffer d') }.

Equations eject {A q} (b : t A (S q)) : { '(b', a1) : t A q * A | seq b' ++ [a1] = seq b } :=
eject (Buffer d) with ncdeque.eject d => { | ? (d', a1) := ? (Buffer d', a1) }.

Equations single {A} (a1 : A) : { b : t A 1 | seq b = [a1] } :=
single a1 with ncdeque.empty => {
  | ? d with ncdeque.push a1 d => {
    | ? d' := ? Buffer d' } }.

Equations pair {A} (a1 a2 : A) : { b : t A 2 | seq b = [a1] ++ [a2] } :=
pair a1 a2 with single a2 => {
  | ? b with push a1 b => { | ? b' := ? b' } }.

Equations triple {A} (a1 a2 a3 : A) : { b : t A 3 | seq b = [a1] ++ [a2] ++ [a3] } :=
triple a1 a2 a3 with pair a2 a3 => {
  | ? b with push a1 b => { | ? b' := ? b' } }.

Equations push2 {A q} (a1 a2 : A) (b : t A q) :
    { b' : t A (S (S q)) | seq b' = [a1] ++ [a2] ++ seq b } :=
push2 a1 a2 b with push a2 b => {
  | ? b' with push a1 b' => {
    | ? b'' := ? b'' } }.

Equations inject2 {A q} (b : t A q) (a2 a1 : A) :
    { b' : t A (S (S q)) | seq b' = seq b ++ [a2] ++ [a1] } :=
inject2 b a2 a1 with inject b a2 => {
  | ? b' with inject b' a1 => {
    | ? b'' := ? b'' } }.

Equations pop2 {A q} (b : t A (S (S q))) : 
    { '(a1, a2, b') : A * A * t A q | [a1] ++ [a2] ++ seq b' = seq b } :=
pop2 b with pop b => {
  | ? (a1, b') with pop b' => {
    | ? (a2, b'') := ? (a1, a2, b'') } }.

Equations eject2 {A q} (b : t A (S (S q))) :
    { '(b', a2, a1) : t A q * A * A | seq b' ++ [a2] ++ [a1] = seq b } :=
eject2 b with eject b => {
  | ? (b', a1) with eject b' => {
    | ? (b'', a2) := ? (b'', a2, a1) } }.

Equations push5 {A q} (a1 a2 a3 a4 a5 : A) (b : t A q) :
    { b' : t A (5 + q) | seq b' = [a1] ++ [a2] ++ [a3] ++ [a4] ++ [a5] ++ seq b } :=
push5 a1 a2 a3 a4 a5 b with push2 a4 a5 b => {
  | ? b' with push2 a2 a3 b' => {
    | ? b'' with push a1 b'' => { | ? b''' := ? b''' } } }.

Equations inject5 {A q} (b : t A q) (a5 a4 a3 a2 a1 : A) :
    { b' : t A (5 + q) | seq b' = seq b ++ [a5] ++ [a4] ++ [a3] ++ [a2] ++ [a1] } :=
inject5 b a5 a4 a3 a2 a1 with inject2 b a5 a4 => {
  | ? b' with inject2 b' a3 a2 => {
    | ? b'' with inject b'' a1 => { | ? b''' := ? b''' } } }.

Equations pop5 {A q} (b : t A (5 + q)) : 
    { '(a1, a2, a3, a4, a5, b') : A * A * A * A * A * t A q | 
        [a1] ++ [a2] ++ [a3] ++ [a4] ++ [a5] ++ seq b' = seq b } :=
pop5 b with pop2 b => {
  | ? (a1, a2, b') with pop2 b' => {
    | ? (a3, a4, b'') with pop b'' => {
      | ? (a5, b''') := ? (a1, a2, a3, a4, a5, b''') } } }.

Equations push6 {A q} (a1 a2 a3 a4 a5 a6 : A) (b : t A q) :
    { b' : t A (6 + q) | seq b' = [a1] ++ [a2] ++ [a3] ++ [a4] ++ [a5] ++ [a6] ++ seq b } :=
push6 a1 a2 a3 a4 a5 a6 b with push5 a2 a3 a4 a5 a6 b => {
  | ? b' with push a1 b' => { | ? b'' := ? b'' } }.

Equations inject6 {A q} (b : t A q) (a6 a5 a4 a3 a2 a1 : A) :
    { b' : t A (6 + q) | seq b' = seq b ++ [a6] ++ [a5] ++ [a4] ++ [a3] ++ [a2] ++ [a1] } :=
inject6 b a6 a5 a4 a3 a2 a1 with inject5 b a6 a5 a4 a3 a2 => {
  | ? b' with inject b' a1 => { | ? b'' := ? b'' } }.

Equations inject8 {A q} (b : t A q) (a8 a7 a6 a5 a4 a3 a2 a1 : A) :
    { b' : t A (8 + q) | seq b' = seq b ++ [a8] ++ [a7] ++ [a6] ++ [a5] ++ [a4] ++ [a3] ++ [a2] ++ [a1] } :=
inject8 b a8 a7 a6 a5 a4 a3 a2 a1 with inject6 b a8 a7 a6 a5 a4 a3 => {
  | ? b' with inject2 b' a2 a1 => { | ? b'' := ? b'' } }.

Equations push_vector {A n q} (v : vector A n) (b : t A q) :
    { b' : t A (q + vector_length v) | seq b' = vector_seq v ++ seq b } :=
push_vector V0 b with translate b _ => { | ? b' := ? b' };
push_vector (V1 a1) b with push a1 b => { 
  | ? b' with translate b' _ => { | ? b'' := ? b'' } };
push_vector (V2 a1 a2) b with push2 a1 a2 b => { 
  | ? b' with translate b' _ => { | ? b'' := ? b'' } };
push_vector (V3 a1 a2 a3) b with push2 a2 a3 b => { 
  | ? b' with push a1 b' => { | ? b'' with translate b'' _ => { 
    | ? b''' := ? b''' } } };
push_vector (V4 a1 a2 a3 a4) b with push2 a3 a4 b => { 
  | ? b' with push2 a1 a2 b' => { | ? b'' with translate b'' _ => { 
    | ? b''' := ? b''' } } };
push_vector (V5 a1 a2 a3 a4 a5) b with push5 a1 a2 a3 a4 a5 b => { 
  | ? b' with translate b' _ => { | ? b'' := ? b'' } };
push_vector (V6 a1 a2 a3 a4 a5 a6) b with push6 a1 a2 a3 a4 a5 a6 b => { 
  | ? b' with translate b' _ => { | ? b'' := ? b'' } }.

Equations inject_vector {A n q} (b : t A q) (v : vector A n) :
    { b' : t A (q + vector_length v) | seq b' = seq b ++ vector_seq v } :=
inject_vector b V0 with translate b _ => { | ? b' := ? b' };
inject_vector b (V1 a1) with inject b a1 => { 
  | ? b' with translate b' _ => { | ? b'' := ? b'' } };
inject_vector b (V2 a1 a2) with inject2 b a1 a2 => { 
  | ? b' with translate b' _ => { | ? b'' := ? b'' } };
inject_vector b (V3 a1 a2 a3) with inject2 b a1 a2 => {
  | ? b' with inject b' a3 => { | ? b'' with translate b'' _ => {
    | ? b''' := ? b''' } } };
inject_vector b (V4 a1 a2 a3 a4) with inject2 b a1 a2 => {
  | ? b' with inject2 b' a3 a4 => { | ? b'' with translate b'' _ => {
    | ? b''' := ? b''' } } };
inject_vector b (V5 a1 a2 a3 a4 a5) with inject5 b a1 a2 a3 a4 a5 => { 
  | ? b' with translate b' _ => { | ? b'' := ? b'' } };
inject_vector b (V6 a1 a2 a3 a4 a5 a6) with inject6 b a1 a2 a3 a4 a5 a6 => { 
  | ? b' with translate b' _ => { | ? b'' := ? b'' } }.

Equations push5_vector {A n q} (a1 a2 a3 a4 a5 : A) (vec : vector A n) (b : t A q) :
    { b' : t A (5 + q + vector_length vec) | 
        seq b' = [a1] ++ [a2] ++ [a3] ++ [a4] ++ [a5] ++ vector_seq vec ++ seq b } :=
push5_vector a1 a2 a3 a4 a5 vec b with push_vector vec b => {
  | ? b' with push5 a1 a2 a3 a4 a5 b' => { | ? b'' := ? b'' } }.

Equations inject5_vector {A n q} (b : t A q) (a5 a4 a3 a2 a1 : A) (vec : vector A n) :
    { b' : t A (5 + q + vector_length vec) | 
        seq b' = seq b ++ [a5] ++ [a4] ++ [a3] ++ [a2] ++ [a1] ++ vector_seq vec } :=
inject5_vector b a5 a4 a3 a2 a1 vec with inject5 b a5 a4 a3 a2 a1 => {
  | ? b' with inject_vector b' vec => { | ? b'' := ? b'' } }.

#[export] Hint Rewrite empty_buffer : rbuffer.

#[local] Obligation Tactic :=
  try first [ done | cbn; hauto db:rbuffer ].

Equations two {A} (b : t A 2) : { '(a1, a2) : A * A | [a1] ++ [a2] = seq b } :=
two b with pop b => {
  | ? (a1, b') with pop b' => {
    | ? (a2, _) := ? (a1, a2) } }.

Equations has1 {A q} (b : t A q) : 
    { o : option (pt A 1 q) | match o with None => [] | Some b' => seq b' end = seq b } :=
has1 (q := 0) _ := ? None;
has1 (q := S q') b := ? Some b.

Equations has5 {A q} (b : t A (4 + q)) :
    { s : sum (A * A * A * A) (pt A 5 (4 + q)) | 
        match s with 
        | inl (a1, a2, a3, a4) => [a1] ++ [a2] ++ [a3] ++ [a4] 
        | inr b' => seq b'
        end = seq b } :=
has5 (q := 0) b with pop2 b => {
  | ? (a1, a2, b') with two b' => {
    | ? (a3, a4) := ? inl (a1, a2, a3, a4) } };
has5 (q := S q') b := ? inr b.

Equations has5p2 {A q} (b : t A (S q)) :
    { s : sum (vector A 6) (pt A 5 (Nat.pred q) * A * A) |
        match s with 
        | inl vec => vector_seq vec 
        | inr (b', a2, a1) => seq b' ++ [a2] ++ [a1]
        end = seq b } :=
has5p2 (q := 0) b with pop b => { | ? (a1, _) := ? inl (V1 a1) };
has5p2 (q := 1) b with two b => { | ? (a1, a2) := ? inl (V2 a1 a2) };
has5p2 (q := 2) b with pop2 b => {
  | ? (a1, a2, b') with pop b' => { | ? (a3, _) := ? inl (V3 a1 a2 a3) } };
has5p2 (q := 3) b with pop2 b => {
  | ? (a1, a2, b') with two b' => { | ? (a3, a4) := ? inl (V4 a1 a2 a3 a4) } };
has5p2 (q := 4) b with pop5 b => {
  | ? (a1, a2, a3, a4, a5, _) := ? inl (V5 a1 a2 a3 a4 a5 ) };
has5p2 (q := 5) b with pop5 b => {
  | ? (a1, a2, a3, a4, a5, b') with pop b' => {
    | ? (a6, _) := ? inl (V6 a1 a2 a3 a4 a5 a6) } };
has5p2 (q := _) b with eject2 b => {
  | ? (b', a2, a1) := ? inr (b', a2, a1) }.

Equations has2p5 {A q} (b : t A (S q)) :
    { s : sum (vector A 6) (A * A * pt A 5 (Nat.pred q)) | 
        match s with 
        | inl vec => vector_seq vec
        | inr (a1, a2, b') => [a1] ++ [a2] ++ seq b'
        end = seq b } :=
has2p5 (q := 0) b with pop b => { | ? (a1, _) := ? inl (V1 a1) };
has2p5 (q := 1) b with two b => { | ? (a1, a2) := ? inl (V2 a1 a2) };
has2p5 (q := 2) b with pop2 b => {
  | ? (a1, a2, b') with pop b' => { | ? (a3, _) := ? inl (V3 a1 a2 a3) } };
has2p5 (q := 3) b with pop2 b => {
  | ? (a1, a2, b') with two b' => { | ? (a3, a4) := ? inl (V4 a1 a2 a3 a4) } };
has2p5 (q := 4) b with pop5 b => {
  | ? (a1, a2, a3, a4, a5, _) := ? inl (V5 a1 a2 a3 a4 a5) };
has2p5 (q := 5) b with pop5 b => {
  | ? (a1, a2, a3, a4, a5, b') with pop b' => {
    | ? (a6, _) := ? inl (V6 a1 a2 a3 a4 a5 a6) } };
has2p5 (q := _) b with pop2 b => {
  | ? (a1, a2, b') := ? inr (a1, a2, b') }.

Equations has8 {A q} (b : t A (5 + q)) :
    { s : sum (A * A * A * A * A * vector A 2) (pt A 8 (5 + q)) | 
        match s with 
        | inl (a1, a2, a3, a4, a5, vec) => 
            [a1] ++ [a2] ++ [a3] ++ [a4] ++ [a5] ++ vector_seq vec
        | inr b' => seq b'
        end = seq b } :=
has8 (q := 0) b with pop5 b => {
  | ? (a1, a2, a3, a4, a5, _) := ? inl (a1, a2, a3, a4, a5, V0) };
has8 (q := 1) b with pop5 b => {
  | ? (a1, a2, a3, a4, a5, b') with pop b' => {
    | ? (a6, _) := ? inl (a1, a2, a3, a4, a5, V1 a6) } };
has8 (q := 2) b with pop5 b => {
  | ? (a1, a2, a3, a4, a5, b') with two b' => {
    | ? (a6, a7) := ? inl (a1, a2, a3, a4, a5, V2 a6 a7) } };
has8 (q := _) b := ? inr b.

Equations has3p8 {A q} (b : t A (8 + q)) :
    {s : sum (A * A * A * A * A * A * A * A * vector A 2) (A * A * A * pt A 8 (5 + q)) | 
        match s with 
        | inl (a1, a2, a3, a4, a5, a6, a7, a8, vec) =>
            [a1] ++ [a2] ++ [a3] ++ [a4] ++ [a5] ++ [a6] ++ [a7] ++ [a8] ++ vector_seq vec 
        | inr (a1, a2, a3, b') => [a1] ++ [a2] ++ [a3] ++ seq b' 
        end = seq b } :=
has3p8 (q := 0) b with pop5 b => {
  | ? (a1, a2, a3, a4, a5, b') with pop2 b' => {
    | ? (a6, a7, b'') with pop b'' => {
      | ? (a8, _) := ? inl (a1, a2, a3, a4, a5, a6, a7, a8, V0) } } };
has3p8 (q := 1) b with pop5 b => {
  | ? (a1, a2, a3, a4, a5, b') with pop2 b' => {
    | ? (a6, a7, b'') with two b'' => {
      | ? (a8, a9) := ? inl (a1, a2, a3, a4, a5, a6, a7, a8, V1 a9) } } };
has3p8 (q := 2) b with pop5 b => {
  | ? (a1, a2, a3, a4, a5, b') with pop5 b' => {
    | ? (a6, a7, a8, a9, a10, _) := ? inl (a1, a2, a3, a4, a5, a6, a7, a8, V2 a9 a10) } };
has3p8 (q := _) b with pop2 b => {
  | ? (a1, a2, b') with pop b' => {
    | ? (a3, b'') := ? inr (a1, a2, a3, b'') } }.