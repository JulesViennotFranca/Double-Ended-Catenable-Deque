From Coq Require Import ssreflect.
From Coq Require Import List.
Import ListNotations.
From Equations Require Import Equations.
Require Import Coq.Program.Equality.
From Hammer Require Import Tactics.
From AAC_tactics Require Import AAC.
From AAC_tactics Require Import Instances.
Import Instances.Lists.

From Cdeque Require Import buffer types UIP_color models.

(* The list application is made opaque. *)

Opaque app.
Definition singleton {A : Type} (x : A) : list A := [x].
Opaque singleton.

(* A list of tactics to be used when trying to resolve obligations generated by
   Equations. *)
#[export] Hint Rewrite <-app_assoc : rassoc.
#[export] Hint Rewrite app_assoc : lassoc.
#[export] Hint Rewrite <-app_comm_cons : rlist.
#[export] Hint Rewrite app_nil_r : rlist.
#[export] Hint Rewrite app_nil_l : rlist.
#[export] Hint Rewrite map_app : rlist.
#[export] Hint Rewrite concat_app : rlist.

#[export] Hint Rewrite stored_triple_ground : rlist.
#[export] Hint Rewrite stored_triple_small : rlist.
#[export] Hint Rewrite stored_triple_big : rlist.
#[export] Hint Rewrite chain_empty : rlist.
#[export] Hint Rewrite chain_only : rlist.
#[export] Hint Rewrite chain_pair : rlist.

Opaque stored_triple_seq.
Opaque chain_seq.

#[export] Hint Rewrite empty_buffer : rlist.

(* A mettre dans models.v *)

Lemma empty_chain_seq [A lvl pk Cl Cr] (c : chain A lvl pk Only Is_end Cl Cr) :
  chain_seq c = [].
Proof.
  dependent destruction c.
  apply chain_empty.
Qed.

#[export] Hint Rewrite empty_chain_seq : rlist.

#[local] Obligation Tactic :=
  try first [ done |
    cbn; intros;
    try simp buffer_seq in *;
    hauto db:rlist ].

Notation "? x" := (@exist _ _ x _) (at level 100).

Equations push_left_storage {A lvl e C}
  (a1 : stored_triple A lvl)
  (st : storage A lvl Left e C) :
  { st' : storage A lvl Left e C |
    storage_left_seq st' = stored_triple_seq a1 ++ storage_left_seq st
    /\ storage_right_seq st' = storage_right_seq st } :=
push_left_storage a1 (Left_end p s) with buffer.push a1 p => {
  | ? p' := ? Left_end p' s };
push_left_storage a1 (Left_st G p s) with buffer.push a1 p => {
  | ? p' := ? Left_st G p' s };
push_left_storage a1 (Left_st Y p s) with buffer.push a1 p => {
  | ? p' := ? Left_st Y p' s };
push_left_storage a1 (Left_st O p s) with buffer.push a1 p => {
  | ? p' := ? Left_st O p' s };
push_left_storage a1 (Left_st R p s) with buffer.push a1 p => {
  | ? p' := ? Left_st R p' s }.

(* TODO : rename Empty in chain into Ending, rename front and rear in left and right. *)

Equations inject_right_storage {A lvl e C}
  (st : storage A lvl Right e C)
  (a1 : stored_triple A lvl) :
  { st' : storage A lvl Right e C |
    storage_left_seq st' = storage_left_seq st /\
    storage_right_seq st' = storage_right_seq st ++ stored_triple_seq a1 } :=
inject_right_storage (Right_end p s) a1 with buffer.inject s a1 => {
  | ? s' := ? Right_end p s' };
inject_right_storage (Right_st G p s) a1 with buffer.inject s a1 => {
  | ? s' := ? Right_st G p s' };
inject_right_storage (Right_st Y p s) a1 with buffer.inject s a1 => {
  | ? s' := ? Right_st Y p s' };
inject_right_storage (Right_st O p s) a1 with buffer.inject s a1 => {
  | ? s' := ? Right_st O p s' };
inject_right_storage (Right_st R p s) a1 with buffer.inject s a1 => {
  | ? s' := ? Right_st R p s' }.

Equations push_only_storage_prop {A lvl e C}
  (a1 : stored_triple A lvl)
  (st1 st2 : storage A lvl Only e C) : Prop :=
push_only_storage_prop (e := Is_end) a1 st1 st2 :=
  storage_left_seq st2 ++ storage_right_seq st2 =
  stored_triple_seq a1 ++ storage_left_seq st1 ++ storage_right_seq st1;
push_only_storage_prop (e := Not_end) a1 st1 st2 :=
  storage_left_seq st2 = stored_triple_seq a1 ++ storage_left_seq st1
  /\ storage_right_seq st2 = storage_right_seq st1.
Transparent push_only_storage_prop.

Equations inject_only_storage_prop {A lvl e C}
  (st1 : storage A lvl Only e C) (a1 : stored_triple A lvl)
  (st2 : storage A lvl Only e C) : Prop :=
inject_only_storage_prop (e := Is_end) st1 a1 st2 :=
  storage_left_seq st2 ++ storage_right_seq st2 =
  storage_left_seq st1 ++ storage_right_seq st1 ++ stored_triple_seq a1;
inject_only_storage_prop (e := Not_end) st1 a1 st2 :=
  storage_left_seq st2 = storage_left_seq st1 /\
  storage_right_seq st2 = storage_right_seq st1 ++ stored_triple_seq a1.
Transparent inject_only_storage_prop.

Equations push_only_storage {A lvl e C}
  (a1 : stored_triple A lvl)
  (st : storage A lvl Only e C) :
  { st' : storage A lvl Only e C |
    push_only_storage_prop a1 st st' } :=
push_only_storage a1 (Only_end p) with buffer.push a1 p => {
  | ? p' := ? Only_end p' };
push_only_storage a1 (Only_st G p s) with buffer.push a1 p => {
  | ? p' := ? Only_st G p' s };
push_only_storage a1 (Only_st Y p s) with buffer.push a1 p => {
  | ? p' := ? Only_st Y p' s };
push_only_storage a1 (Only_st O p s) with buffer.push a1 p => {
  | ? p' := ? Only_st O p' s };
push_only_storage a1 (Only_st R p s) with buffer.push a1 p => {
  | ? p' := ? Only_st R p' s }.

Equations inject_only_storage {A lvl e C}
  (st : storage A lvl Only e C)
  (a1 : stored_triple A lvl) :
  { st' : storage A lvl Only e C |
    inject_only_storage_prop st a1 st' } :=
inject_only_storage (Only_end p) a1 with buffer.inject p a1 => {
  | ? p' := ? Only_end p' };
inject_only_storage (Only_st G p s) a1 with buffer.inject s a1 => {
  | ? s' := ? Only_st G p s' };
inject_only_storage (Only_st Y p s) a1 with buffer.inject s a1 => {
  | ? s' := ? Only_st Y p s' };
inject_only_storage (Only_st O p s) a1 with buffer.inject s a1 => {
  | ? s' := ? Only_st O p s' };
inject_only_storage (Only_st R p s) a1 with buffer.inject s a1 => {
  | ? s' := ? Only_st R p s' }.

#[local] Obligation Tactic := try first [ done | hauto db:rassoc,rlist ].

Equations push_left_packet {A hlvl tlvl e C}
  (a1 : stored_triple A hlvl)
  (pkt : packet A hlvl tlvl Left e C) :
  { pkt' : packet A hlvl tlvl Left e C |
    packet_left_seq pkt' = stored_triple_seq a1 ++ packet_left_seq pkt
    /\ packet_right_seq pkt' = packet_right_seq pkt } :=
push_left_packet a1 (Packet Hole tl) with push_left_storage a1 tl => {
  | ? tl' := ? Packet Hole tl' };
push_left_packet a1 (Packet (Only_yellow hd bd) tl) with push_left_storage a1 hd => {
  | ? hd' := ? Packet (Only_yellow hd' bd) tl };
push_left_packet a1 (Packet (Only_orange hd bd) tl) with push_left_storage a1 hd => {
  | ? hd' := ? Packet (Only_orange hd' bd) tl };
push_left_packet a1 (Packet (Pair_yellow hd bd cr) tl) with push_left_storage a1 hd => {
  | ? hd' := ? Packet (Pair_yellow hd' bd cr) tl };
push_left_packet a1 (Packet (Pair_orange hd cl bd) tl) with push_left_storage a1 hd => {
  | ? hd' := ? Packet (Pair_orange hd' cl bd) tl }.

Equations inject_right_packet {A hlvl tlvl e C}
  (pkt : packet A hlvl tlvl Right e C)
  (a1 : stored_triple A hlvl) :
  { pkt' : packet A hlvl tlvl Right e C |
    packet_left_seq pkt' = packet_left_seq pkt /\
    packet_right_seq pkt' = packet_right_seq pkt ++ stored_triple_seq a1 } :=
inject_right_packet (Packet Hole tl) a1 with inject_right_storage tl a1 => {
  | ? tl' := ? Packet Hole tl' };
inject_right_packet (Packet (Only_yellow hd bd) tl) a1 with inject_right_storage hd a1 => {
  | ? hd' := ? Packet (Only_yellow hd' bd) tl };
inject_right_packet (Packet (Only_orange hd bd) tl) a1 with inject_right_storage hd a1 => {
  | ? hd' := ? Packet (Only_orange hd' bd) tl };
inject_right_packet (Packet (Pair_yellow hd bd cr) tl) a1 with inject_right_storage hd a1 => {
  | ? hd' := ? Packet (Pair_yellow hd' bd cr) tl };
inject_right_packet (Packet (Pair_orange hd cl bd) tl) a1 with inject_right_storage hd a1 => {
  | ? hd' := ? Packet (Pair_orange hd' cl bd) tl }.

Equations push_only_packet_prop {A hlvl tlvl e C}
  (a1 : stored_triple A hlvl)
  (pkt1 pkt2 : packet A hlvl tlvl Only e C) : Prop :=
push_only_packet_prop (e := Is_end) a1 pkt1 pkt2 :=
  packet_left_seq pkt2 ++ packet_right_seq pkt2 =
  stored_triple_seq a1 ++ packet_left_seq pkt1 ++ packet_right_seq pkt1;
push_only_packet_prop (e := Not_end) a1 pkt1 pkt2 :=
  packet_left_seq pkt2 = stored_triple_seq a1 ++ packet_left_seq pkt1
  /\ packet_right_seq pkt2 = packet_right_seq pkt1.
Transparent push_only_packet_prop.

Equations inject_only_packet_prop {A hlvl tlvl e C}
  (pkt1 : packet A hlvl tlvl Only e C) (a1 : stored_triple A hlvl)
  (pkt2 : packet A hlvl tlvl Only e C) : Prop :=
inject_only_packet_prop (e := Is_end) pkt1 a1 pkt2 :=
  packet_left_seq pkt2 ++ packet_right_seq pkt2 =
  packet_left_seq pkt1 ++ packet_right_seq pkt1 ++ stored_triple_seq a1;
inject_only_packet_prop (e := Not_end) pkt1 a1 pkt2 :=
  packet_left_seq pkt2 = packet_left_seq pkt1 /\
  packet_right_seq pkt2 = packet_right_seq pkt1 ++ stored_triple_seq a1.
Transparent inject_only_packet_prop.

Ltac destruct_ending :=
  repeat
  match goal with
  | e : ending |- _ => destruct e
  end.

#[local] Obligation Tactic :=
  try first [ done | intros; destruct_ending; cbn in *; hauto db:rassoc,rlist ].

Equations push_only_packet {A hlvl tlvl e C}
  (a1 : stored_triple A hlvl)
  (pkt : packet A hlvl tlvl Only e C) :
  { pkt' : packet A hlvl tlvl Only e C |
    push_only_packet_prop a1 pkt pkt' } :=
push_only_packet a1 (Packet Hole tl) with push_only_storage a1 tl => {
  | ? tl' := ? Packet Hole tl' };
push_only_packet a1 (Packet (Only_yellow hd bd) tl) with push_only_storage a1 hd => {
  | ? hd' := ? Packet (Only_yellow hd' bd) tl };
push_only_packet a1 (Packet (Only_orange hd bd) tl) with push_only_storage a1 hd => {
  | ? hd' := ? Packet (Only_orange hd' bd) tl };
push_only_packet a1 (Packet (Pair_yellow hd bd cr) tl) with push_only_storage a1 hd => {
  | ? hd' := ? Packet (Pair_yellow hd' bd cr) tl };
push_only_packet a1 (Packet (Pair_orange hd cl bd) tl) with push_only_storage a1 hd => {
  | ? hd' := ? Packet (Pair_orange hd' cl bd) tl }.

Equations inject_only_packet {A hlvl tlvl e C}
  (pkt : packet A hlvl tlvl Only e C)
  (a1 : stored_triple A hlvl) :
  { pkt' : packet A hlvl tlvl Only e C |
    inject_only_packet_prop pkt a1 pkt' } :=
inject_only_packet (Packet Hole tl) a1 with inject_only_storage tl a1 => {
  | ? tl' := ? Packet Hole tl' };
inject_only_packet (Packet (Only_yellow hd bd) tl) a1 with inject_only_storage hd a1 => {
  | ? hd' := ? Packet (Only_yellow hd' bd) tl };
inject_only_packet (Packet (Only_orange hd bd) tl) a1 with inject_only_storage hd a1 => {
  | ? hd' := ? Packet (Only_orange hd' bd) tl };
inject_only_packet (Packet (Pair_yellow hd bd cr) tl) a1 with inject_only_storage hd a1 => {
  | ? hd' := ? Packet (Pair_yellow hd' bd cr) tl };
inject_only_packet (Packet (Pair_orange hd cl bd) tl) a1 with inject_only_storage hd a1 => {
  | ? hd' := ? Packet (Pair_orange hd' cl bd) tl }.

Equations single_storage {A lvl}
  (a1 : stored_triple A lvl) :
  { st : storage A lvl Only Is_end green |
    storage_left_seq st = stored_triple_seq a1 /\ storage_right_seq st = [] } :=
single_storage a1 with buffer.single a1 => { | ? p := ? Only_end p }.
Next Obligation.
  cbn; intros; simp buffer_seq. hauto db:rassoc, rlist.
Qed.

Equations single_packet {A lvl}
  (a1 : stored_triple A lvl) :
  { pkt : packet A lvl lvl Only Is_end green |
    packet_left_seq pkt = stored_triple_seq a1 /\ packet_right_seq pkt = [] } :=
single_packet a1 with single_storage a1 => { | ? tl := ? Packet Hole tl }.

Equations single_chain {A lvl}
  (a1 : stored_triple A lvl) :
  { c : chain A lvl Only Only Not_end green green |
    chain_seq c = stored_triple_seq a1 } :=
single_chain a1 with single_packet a1 => {
  | ? pkt := ? Only_chain Green_chain pkt Empty }.

(* On peut peut-être renommer Only_chain et Pair_chain en Only et Pair. *)

Set Equations With UIP.

Equations push_left_chain {A lvl C}
  (a1 : stored_triple A lvl)
  (c : chain A lvl Only Left Not_end C C) :
  { c' : chain A lvl Only Left Not_end C C |
    chain_seq c' = stored_triple_seq a1 ++ chain_seq c } :=
push_left_chain a1 (Only_chain reg pkt c) with push_left_packet a1 pkt => {
    | ? pkt' := ? Only_chain reg pkt' c }.

Equations inject_right_chain {A lvl C}
  (c : chain A lvl Only Right Not_end C C)
  (a1 : stored_triple A lvl) :
  { c' : chain A lvl Only Right Not_end C C |
    chain_seq c' = chain_seq c ++ stored_triple_seq a1 } :=
inject_right_chain (Only_chain reg pkt c) a1 with inject_right_packet pkt a1 => {
    | ? pkt' := ? Only_chain reg pkt' c }.

Equations push_chain {A lvl pk e Cl Cr}
  (a1 : stored_triple A lvl)
  (c : chain A lvl pk Only e Cl Cr) :
  { c' : chain A lvl pk Only Not_end Cl Cr |
    chain_seq c' = stored_triple_seq a1 ++ chain_seq c } :=
push_chain a1 Empty with single_chain a1 => { | ? c := ? c };
push_chain a1 (Only_chain reg pkt c) with push_only_packet a1 pkt => {
  | ? pkt' := ? Only_chain reg pkt' c };
push_chain a1 (Pair_chain cl cr) with push_left_chain a1 cl => {
  | ? cl' := ? Pair_chain cl' cr }.

Equations inject_chain {A lvl pk e Cl Cr}
  (c : chain A lvl pk Only e Cl Cr)
  (a1 : stored_triple A lvl) :
  { c' : chain A lvl pk Only Not_end Cl Cr |
    chain_seq c' = chain_seq c ++ stored_triple_seq a1 } :=
inject_chain Empty a1 with single_chain a1 => { | ? c := ? c };
inject_chain (Only_chain reg pkt c) a1 with inject_only_packet pkt a1 => {
  | ? pkt' := ? Only_chain reg pkt' c };
inject_chain (Pair_chain cl cr) a1 with inject_right_chain cr a1 => {
  | ? cr' := ? Pair_chain cl cr' }.

#[local] Obligation Tactic :=
  try first [ done | intros; cbn in *; hauto db:rassoc,rlist ].

Equations push_ne_chain {A lvl pk Cl Cr}
  (a1 : stored_triple A lvl)
  (c : non_ending_chain A lvl pk Only Cl Cr) :
  { c' : non_ending_chain A lvl pk Only Cl Cr |
    ne_chain_seq c' = stored_triple_seq a1 ++ ne_chain_seq c } :=
push_ne_chain a1 (NE_chain c) with push_chain a1 c => {
  | ? c' := ? NE_chain c' }.

Equations inject_ne_chain {A lvl pk Cl Cr}
  (c : non_ending_chain A lvl pk Only Cl Cr)
  (a1 : stored_triple A lvl) :
  { c' : non_ending_chain A lvl pk Only Cl Cr |
    ne_chain_seq c' = ne_chain_seq c ++ stored_triple_seq a1 } :=
inject_ne_chain (NE_chain c) a1 with inject_chain c a1 => {
  | ? c' := ? NE_chain c' }.

Equations push_vector {A lvl n pk Cl Cr}
  (v : vector (stored_triple A lvl) n)
  (c : non_ending_chain A lvl pk Only Cl Cr) :
  { c' : non_ending_chain A lvl pk Only Cl Cr |
    ne_chain_seq c' = concat (map stored_triple_seq (vector_seq v)) ++ ne_chain_seq c } :=
push_vector V0 c := ? c;
push_vector (V1 a1) c with push_ne_chain a1 c => { | ? c1 := ? c1 };
push_vector (V2 a1 a2) c with push_ne_chain a2 c => {
  | ? c2 with push_ne_chain a1 c2 => { | ? c1 := ? c1 } };
push_vector (V3 a1 a2 a3) c with push_ne_chain a3 c => {
  | ? c3 with push_ne_chain a2 c3 => { | ? c2 with push_ne_chain a1 c2 => {
    | ? c1 := ? c1 } } };
push_vector (V4 a1 a2 a3 a4) c with push_ne_chain a4 c => {
  | ? c4 with push_ne_chain a3 c4 => { | ? c3 with push_ne_chain a2 c3 => {
    | ? c2 with push_ne_chain a1 c2 => { | ? c1 := ? c1 } } } };
push_vector (V5 a1 a2 a3 a4 a5) c with push_ne_chain a5 c => {
  | ? c5 with push_ne_chain a4 c5 => { | ? c4 with push_ne_chain a3 c4 => {
    | ? c3 with push_ne_chain a2 c3 => { | ? c2 with push_ne_chain a1 c2 => {
      | ? c1 := ? c1 } } } } };
push_vector (V6 a1 a2 a3 a4 a5 a6) c with push_ne_chain a6 c => {
  | ? c6 with push_ne_chain a5 c6 => { | ? c5 with push_ne_chain a4 c5 => {
    | ? c4 with push_ne_chain a3 c4 => { | ? c3 with push_ne_chain a2 c3 => {
      | ? c2 with push_ne_chain a1 c2 => { | ? c1 := ? c1 } } } } } }.

Equations inject_vector {A lvl n pk Cl Cr}
  (c : non_ending_chain A lvl pk Only Cl Cr)
  (v : vector (stored_triple A lvl) n) :
  { c' : non_ending_chain A lvl pk Only Cl Cr |
    ne_chain_seq c' = ne_chain_seq c ++ concat (map stored_triple_seq (vector_seq v)) } :=
inject_vector c V0 := ? c;
inject_vector c (V1 a1) with inject_ne_chain c a1 => { | ? c1 := ? c1 };
inject_vector c (V2 a1 a2) with inject_ne_chain c a1 => {
  | ? c1 with inject_ne_chain c1 a2 => { | ? c2 := ? c2 } };
inject_vector c (V3 a1 a2 a3) with inject_ne_chain c a1 => {
  | ? c1 with inject_ne_chain c1 a2 => { | ? c2 with inject_ne_chain c2 a3 => {
    | ? c3 := ? c3 } } };
inject_vector c (V4 a1 a2 a3 a4) with inject_ne_chain c a1 => {
  | ? c1 with inject_ne_chain c1 a2 => { | ? c2 with inject_ne_chain c2 a3 => {
    | ? c3 with inject_ne_chain c3 a4 => { | ? c4 := ? c4 } } } };
inject_vector c (V5 a1 a2 a3 a4 a5) with inject_ne_chain c a1 => {
  | ? c1 with inject_ne_chain c1 a2 => { | ? c2 with inject_ne_chain c2 a3 => {
    | ? c3 with inject_ne_chain c3 a4 => { | ? c4 with inject_ne_chain c4 a5 => {
      | ? c5 := ? c5 } } } } };
inject_vector c (V6 a1 a2 a3 a4 a5 a6) with inject_ne_chain c a1 => {
  | ? c1 with inject_ne_chain c1 a2 => { | ? c2 with inject_ne_chain c2 a3 => {
    | ? c3 with inject_ne_chain c3 a4 => { | ? c4 with inject_ne_chain c4 a5 => {
      | ? c5 with inject_ne_chain c5 a6 => { | ? c6 := ? c6 } } } } } }.

Equations push_semi {A lvl}
  (a1 : stored_triple A lvl)
  (sd : semi_deque A lvl) :
  { sd' : semi_deque A lvl |
    semi_deque_seq sd' = stored_triple_seq a1 ++ semi_deque_seq sd } :=
push_semi a1 (Semi c) with push_chain a1 c => { | ? c' := ? Semi c' }.

Equations inject_semi {A lvl}
  (sd : semi_deque A lvl)
  (a1 : stored_triple A lvl) :
  { sd' : semi_deque A lvl |
    semi_deque_seq sd' = semi_deque_seq sd ++ stored_triple_seq a1 } :=
inject_semi (Semi c) a1 with inject_chain c a1 => { | ? c' := ? Semi c' }.

Equations triple_of_chain {A lvl k C}  (c : chain A lvl Only k Not_end C C) :
  { t : triple A lvl k C | triple_seq t = chain_seq c } :=
triple_of_chain (Only_chain Green_chain (Packet Hole tl) child) :=
  ? Triple Green tl child;
triple_of_chain (Only_chain Red_chain (Packet Hole tl) child) :=
  ? Triple Red tl child;
triple_of_chain (Only_chain reg (Packet (Only_yellow hd bd) tl) child) :=
  ? Triple Yellow hd (Only_chain reg (Packet bd tl) child);
triple_of_chain (Only_chain reg (Packet (Only_orange hd bd) tl) child) :=
  ? Triple OrangeO hd (Only_chain reg (Packet bd tl) child);
triple_of_chain (Only_chain reg (Packet (Pair_yellow hd bd cr) tl) child) :=
  ? Triple Yellow hd (Pair_chain (Only_chain reg (Packet bd tl) child) cr);
triple_of_chain (Only_chain reg (Packet (Pair_orange hd cl bd) tl) child) :=
  ? Triple OrangeP hd (Pair_chain cl (Only_chain reg (Packet bd tl) child)).

Equations chain_of_triple {A lvl k C} (t : triple A lvl k C) :
  { c : chain A lvl Only k Not_end C C | chain_seq c = triple_seq t } :=
chain_of_triple (Triple Green hd child) :=
  ? Only_chain Green_chain (Packet Hole hd) child;
chain_of_triple (Triple Yellow hd (Only_chain reg (Packet bd tl) child)) :=
  ? Only_chain reg (Packet (Only_yellow hd bd) tl) child;
chain_of_triple (Triple Yellow hd (Pair_chain (Only_chain reg (Packet bd tl) child) cr)) :=
  ? Only_chain reg (Packet (Pair_yellow hd bd cr) tl) child;
chain_of_triple (Triple OrangeO hd (Only_chain reg (Packet bd tl) child)) :=
  ? Only_chain reg (Packet (Only_orange hd bd) tl) child;
chain_of_triple (Triple OrangeP hd (Pair_chain cl (Only_chain reg (Packet bd tl) child))) :=
  ? Only_chain reg (Packet (Pair_orange hd cl bd) tl) child;
chain_of_triple (Triple Red hd child) :=
  ? Only_chain Red_chain (Packet Hole hd) child.

#[local] Obligation Tactic :=
  try first [ done |
    intros; cbn in *;
    autorewrite with rlist;
    try unfold prefix_seq, suffix_seq, buffer_seq;
    hauto db:rassoc,rlist ].

Equations left_of_only {A lvl C} (t : triple A lvl Only C) :
  { lt : left_right_triple A lvl Left C | lr_triple_seq lt = triple_seq t } :=
left_of_only (Triple Green (Only_end p) Empty) with buffer.has7 p => {
  | ? inl v := ? Not_enough v;
  | ? inr p1 with buffer.eject2 p1 => {
    | ? (p2, a2, a1) with buffer.pair a2 a1 => {
      | ? s := ? Ok_lrt (Triple Green (Left_end p2 s) Empty) } } };
left_of_only (Triple reg (Only_st coloring p s) child) with buffer.eject2 s => {
  | ? (s1, a2, a1) with buffer.pair a2 a1, inject_chain child (Small s1) => {
    | ? s2, ? child1 := ? Ok_lrt (Triple reg (Left_st coloring p s2) child1) } }.

Equations right_of_only {A lvl C} (t : triple A lvl Only C) :
  { rt : left_right_triple A lvl Right C | lr_triple_seq rt = triple_seq t } :=
right_of_only (Triple Green (Only_end s) Empty) with buffer.has7 s => {
  | ? inl v := ? Not_enough v;
  | ? inr s1 with buffer.pop2 s1 => {
    | ? (a1, a2, s2) with buffer.pair a1 a2 => {
      | ? p := ? Ok_lrt (Triple Green (Right_end p s2) Empty) } } };
right_of_only (Triple reg (Only_st coloring p s) child) with buffer.pop2 p => {
  | ? (a1, a2, p1) with buffer.pair a1 a2, push_chain (Small p1) child => {
    | ? p2, ? child1 := ? Ok_lrt (Triple reg (Right_st coloring p2 s) child1) } }.

Equations make_stored_suffix {A lvl ql q pk e Cl Cr}
  (sl : suffix A lvl (1 + ql))
  (p : prefix A lvl 2)
  (child : chain A (S lvl) pk Only e Cl Cr)
  (s : suffix A lvl (5 + q)) :
  { '(stored, sleft) : stored_triple A (S lvl) * suffix A lvl 2 |
    stored_triple_seq stored ++ suffix_seq sleft =
    suffix_seq sl ++ prefix_seq p ++ chain_seq child ++ suffix_seq s } :=
make_stored_suffix sl p child s with buffer.two p, buffer.eject2 s => {
  | ? (a1, a2), ? (sstored, c, d) with buffer.inject2 sl a1 a2, buffer.pair c d => {
    | ? pstored, ? sleft := ? (Big pstored child sstored, sleft) } }.

Equations make_prefix_stored {A lvl q qr pk e Cl Cr}
  (p : prefix A lvl (5 + q))
  (child : chain A (S lvl) pk Only e Cl Cr)
  (s : suffix A lvl 2)
  (pr : prefix A lvl (1 + qr)) :
  { '(pright, stored) : prefix A lvl 2 * stored_triple A (S lvl) |
    prefix_seq pright ++ stored_triple_seq stored =
    prefix_seq p ++ chain_seq child ++ suffix_seq s ++ prefix_seq pr } :=
make_prefix_stored p child s pr with buffer.pop2 p, buffer.two s => {
  | ? (a1, a2, pstored), ? (c, d) with buffer.pair a1 a2, buffer.push2 c d pr => {
    | ? pright, ? sstored := ? (pright, Big pstored child sstored) } }.

Equations stored_of_right {A lvl ql C}
  (sl : suffix A lvl (1 + ql))
  (tr : triple A lvl Right C) :
  { '(stored, sleft) : stored_triple A (S lvl) * suffix A lvl 2 |
    stored_triple_seq stored ++ suffix_seq sleft =
    suffix_seq sl ++ triple_seq tr } :=
stored_of_right sl (Triple Green (Right_end p s) Empty)
  with make_stored_suffix sl p Empty s => { | ? res := ? res };
stored_of_right sl (Triple reg (Right_st coloring p s) child)
  with make_stored_suffix sl p child s => { | ? res := ? res }.

Equations stored_of_left {A lvl qr C}
  (tl : triple A lvl Left C)
  (pr : prefix A lvl (1 + qr)) :
  { '(pright, stored) : prefix A lvl 2 * stored_triple A (S lvl) |
    prefix_seq pright ++ stored_triple_seq stored =
    triple_seq tl ++ prefix_seq pr } :=
stored_of_left (Triple Green (Left_end p s) Empty) pr
  with make_prefix_stored p Empty s pr => { | ? res := ? res };
stored_of_left (Triple _ (Left_st _ p s) child) pr
  with make_prefix_stored p child s pr => { | ? res := ? res }.

Equations left_of_pair {A lvl Cl Cr}
  (tl : triple A lvl Left Cl) (tr : triple A lvl Right Cr) :
  { tl' : triple A lvl Left Cl |
    triple_seq tl' = triple_seq tl ++ triple_seq tr } :=
left_of_pair (Triple Green (Left_end p s) Empty) tr with buffer.pop s => {
  | ? (a1, s1) with buffer.inject p a1, stored_of_right s1 tr => {
    | ? p1, ? (stored, s2) with single_chain stored => {
      | ? child := ? Triple OrangeO (Left_st O p1 s2) child } } };
left_of_pair (Triple reg (Left_st coloring p s) child) tr with stored_of_right s tr => {
  | ? (stored, s1) with inject_chain child stored => {
    | ? child1 := ? Triple reg (Left_st coloring p s1) child1 } }.

#[local] Obligation Tactic :=
  try first [ done |
    intros; cbn in *;
    try unfold prefix_seq, suffix_seq, buffer_seq;
    hauto db:lassoc,rlist ].

Equations right_of_pair {A lvl Cl Cr}
  (tl : triple A lvl Left Cl) (tr : triple A lvl Right Cr) :
  { tr' : triple A lvl Right Cr |
    triple_seq tr' = triple_seq tl ++ triple_seq tr } :=
right_of_pair tl (Triple Green (Right_end p s) Empty) with buffer.eject p => {
  | ? (p1, a1) with buffer.push a1 s, stored_of_left tl p1 => {
    | ? s1, ? (p2, stored) with single_chain stored => {
      | ? child := ? Triple OrangeO (Right_st O p2 s1) child } } };
right_of_pair tl (Triple reg (Right_st coloring p s) child) with stored_of_left tl p => {
  | ? (p1, stored) with push_chain stored child => {
    | ? child1 := ? Triple reg (Right_st coloring p1 s) child1 } }.

Equations make_left {A lvl pk e Cl Cr} (c : chain A lvl pk Only e Cl Cr) :
  { t : left_right_triple A lvl Left Cl | lr_triple_seq t = chain_seq c } :=
make_left Empty := ? Not_enough V0;
make_left (Only_chain reg pkt c) with triple_of_chain (Only_chain reg pkt c) => {
  | ? t with left_of_only t => { | ? t' := ? t' } };
make_left (Pair_chain cl cr) with triple_of_chain cl, triple_of_chain cr => {
  | ? tl, ? tr with left_of_pair tl tr => { | ? t := ? Ok_lrt t } }.

Equations make_right {A lvl pk e Cl Cr} (c : chain A lvl pk Only e Cl Cr) :
  { t : left_right_triple A lvl Right Cr | lr_triple_seq t = chain_seq c } :=
make_right Empty := ? Not_enough V0;
make_right (Only_chain reg pkt c) with triple_of_chain (Only_chain reg pkt c) => {
  | ? t with right_of_only t => { | ? t' := ? t' } };
make_right (Pair_chain cl cr) with triple_of_chain cl, triple_of_chain cr => {
  | ? tl, ? tr with right_of_pair tl tr => { | ? t := ? Ok_lrt t } }.

Equations concat_semi {A lvl} (s1 s2 : semi_deque A lvl) :
  { s3 : semi_deque A lvl |
    semi_deque_seq s3 = semi_deque_seq s1 ++ semi_deque_seq s2 } :=
concat_semi (Semi c1) (Semi c2) with make_left c1 => {
  | ? Not_enough v with push_vector v (NE_chain c2) => {
    | ? NE_chain c3 := ? Semi c3 };
  | ? Ok_lrt tl with make_right c2 => {
    | ? Not_enough v with inject_vector (NE_chain c1) v => {
      | ? NE_chain c3 := ? Semi c3 };
    | ? Ok_lrt tr with chain_of_triple tl, chain_of_triple tr => {
      | ? cl, ? cr := ? Semi (Pair_chain cl cr) } } }.

Equations orange_reg {A lvl pk Cr} :
  chain A lvl pk Only Not_end green Cr -> regularity orange pk Not_end green Cr Cr :=
orange_reg (Only_chain _ _ _) := OrangeO;
orange_reg (Pair_chain _ _) := OrangeP.

Equations pop_left_green {A lvl} (tl : triple A lvl Left green) :
  { '(a1, pt) : stored_triple A lvl * partial_triple A lvl Pair Left |
    triple_seq tl = stored_triple_seq a1 ++ pt_triple_seq pt } :=
pop_left_green (Triple Green (Left_end p s) Empty) with buffer.pop p => {
  | ? (a1, p1) with buffer.has5 p1 => {
    | ? inl (a2, a3, a4, a5) with buffer.two s => {
      | ? (a6, a7) := ? (a1, Six_elements (a2, a3, a4, a5, a6, a7)) };
    | ? inr p2 => ? (a1, Ok_pt (Triple Green (Left_end p2 s) Empty)) } };
pop_left_green (Triple Green (Left_st G p s) child) with buffer.pop p => {
  | ? (a1, p1) := ? (a1, Ok_pt (Triple Yellow (Left_st Y p1 s) child)) };
pop_left_green (Triple Yellow (Left_st Y p s) child) with buffer.pop p => {
  | ? (a1, p1) := ? (a1, Ok_pt (Triple (orange_reg child) (Left_st O p1 s) child)) };
pop_left_green (Triple OrangeO (Left_st O p s) child) with buffer.pop p => {
  | ? (a1, p1) := ? (a1, Ok_pt (Triple Red (Left_st R p1 s) child)) };
pop_left_green (Triple OrangeP (Left_st O p s) child) with buffer.pop p => {
  | ? (a1, p1) := ? (a1, Ok_pt (Triple Red (Left_st R p1 s) child)) }.

Equations eject_right_green {A lvl} (tr : triple A lvl Right green) :
  { '(pt, a1) : partial_triple A lvl Pair Right * stored_triple A lvl |
    triple_seq tr = pt_triple_seq pt ++ stored_triple_seq a1 } :=
eject_right_green (Triple Green (Right_end p s) Empty) with buffer.eject s => {
  | ? (s1, a1) with buffer.has5 s1 => {
    | ? inl (a5, a4, a3, a2) with buffer.two p => {
      | ? (a7, a6) := ? (Six_elements (a7, a6, a5, a4, a3, a2), a1) };
    | ? inr s2 => ? (Ok_pt (Triple Green (Right_end p s2) Empty), a1) } };
eject_right_green (Triple Green (Right_st G p s) child) with buffer.eject s => {
  | ? (s1, a1) := ? (Ok_pt (Triple Yellow (Right_st Y p s1) child), a1) };
eject_right_green (Triple Yellow (Right_st Y p s) child) with buffer.eject s => {
  | ? (s1, a1) := ? (Ok_pt (Triple (orange_reg child) (Right_st O p s1) child), a1) };
eject_right_green (Triple OrangeO (Right_st O p s) child) with buffer.eject s => {
  | ? (s1, a1) := ? (Ok_pt (Triple Red (Right_st R p s1) child), a1) };
eject_right_green (Triple OrangeP (Right_st O p s) child) with buffer.eject s => {
  | ? (s1, a1) := ? (Ok_pt (Triple Red (Right_st R p s1) child), a1) }.

Equations pop_only_green {A lvl} (t : triple A lvl Only green) :
  { '(a1, pt) : stored_triple A lvl * partial_triple A lvl Only Only |
    triple_seq t = stored_triple_seq a1 ++ pt_triple_seq pt } :=
pop_only_green (Triple Green (Only_end p) Empty) with buffer.pop p => {
  | ? (a1, p1) with buffer.has1 p1 => {
    | ? None := ? (a1, Zero_element);
    | ? Some p2 := ? (a1, Ok_pt (Triple Green (Only_end p2) Empty)) } };
pop_only_green (Triple Green (Only_st G p s) child) with buffer.pop p => {
  | ? (a1, p1) := ? (a1, Ok_pt (Triple Yellow (Only_st Y p1 s) child)) };
pop_only_green (Triple Yellow (Only_st Y p s) child) with buffer.pop p => {
  | ? (a1, p1) := ? (a1, Ok_pt (Triple (orange_reg child) (Only_st O p1 s) child)) };
pop_only_green (Triple OrangeO (Only_st O p s) child) with buffer.pop p => {
  | ? (a1, p1) := ? (a1, Ok_pt (Triple Red (Only_st R p1 s) child)) };
pop_only_green (Triple OrangeP (Only_st O p s) child) with buffer.pop p => {
  | ? (a1, p1) := ? (a1, Ok_pt (Triple Red (Only_st R p1 s) child)) }.

Equations eject_only_green {A lvl} (t : triple A lvl Only green) :
  { '(pt, a1) : partial_triple A lvl Only Only * stored_triple A lvl |
    triple_seq t = pt_triple_seq pt ++ stored_triple_seq a1 } :=
eject_only_green (Triple Green (Only_end s) Empty) with buffer.eject s => {
  | ? (s1, a1) with buffer.has1 s1 => {
    | ? None := ? (Zero_element, a1);
    | ? Some s2 := ? (Ok_pt (Triple Green (Only_end s2) Empty), a1) } };
eject_only_green (Triple Green (Only_st G p s) child) with buffer.eject s => {
  | ? (s1, a1) := ? (Ok_pt (Triple Yellow (Only_st Y p s1) child), a1) };
eject_only_green (Triple Yellow (Only_st Y p s) child) with buffer.eject s => {
  | ? (s1, a1) := ? (Ok_pt (Triple (orange_reg child) (Only_st O p s1) child), a1) };
eject_only_green (Triple OrangeO (Only_st O p s) child) with buffer.eject s => {
  | ? (s1, a1) := ? (Ok_pt (Triple Red (Only_st R p s1) child), a1) };
eject_only_green (Triple OrangeP (Only_st O p s) child) with buffer.eject s => {
  | ? (s1, a1) := ? (Ok_pt (Triple Red (Only_st R p s1) child), a1) }.

Equations sandwich_only_green {A lvl} (t : triple A lvl Only green) :
  { s : sandwich (stored_triple A lvl) (partial_triple A lvl Only Only) |
    triple_seq t = sandwich_seq stored_triple_seq pt_triple_seq s } :=
sandwich_only_green (Triple Green (Only_end p) Empty) with buffer.pop p => {
  | ? (a1, p1) with buffer.has1 p1 => {
    | ? None := ? Alone a1;
    | ? Some s with buffer.eject s => {
      | ? (s1, z1) with buffer.has1 s1 => {
        | ? None := ? Sandwich a1 Zero_element z1;
        | ? Some b := ? Sandwich a1 (Ok_pt (Triple Green (Only_end b) Empty)) z1 } } } };
sandwich_only_green (Triple Green (Only_st G p s) child)
  with buffer.pop p, buffer.eject s => { | ? (a1, p1), ? (s1, z1) :=
    ? Sandwich a1 (Ok_pt (Triple Yellow (Only_st Y p1 s1) child)) z1 };
sandwich_only_green (Triple Yellow (Only_st Y p s) child)
  with buffer.pop p, buffer.eject s => { | ? (a1, p1), ? (s1, z1) :=
    ? Sandwich a1 (Ok_pt (Triple (orange_reg child) (Only_st O p1 s1) child)) z1 };
sandwich_only_green (Triple OrangeO (Only_st O p s) child)
  with buffer.pop p, buffer.eject s => { | ? (a1, p1), ? (s1, z1) :=
    ? Sandwich a1 (Ok_pt (Triple Red (Only_st R p1 s1) child)) z1 };
sandwich_only_green (Triple OrangeP (Only_st O p s) child)
  with buffer.pop p, buffer.eject s => { | ? (a1, p1), ? (s1, z1) :=
    ? Sandwich a1 (Ok_pt (Triple Red (Only_st R p1 s1) child)) z1 }.

Equations adapt_to_prefix {qp qs q C} :
  coloring qp qs C -> coloring (3 + q) qs C :=
adapt_to_prefix G := G;
adapt_to_prefix Y := Y;
adapt_to_prefix O := O;
adapt_to_prefix R := R.

Equations only_of_right {A lvl C}
  (six : six_stored_triple A lvl)
  (tr : triple A lvl Right C) :
  { t : triple A lvl Only C |
    triple_seq t = six_stored_triple_seq six ++ triple_seq tr } :=
only_of_right (a1, a2, a3, a4, a5, a6) (Triple Green (Right_end p s) Empty)
  with buffer.two p => {
    | ? (a7, a8) with buffer.push2 a7 a8 s => {
      | ? s1 with buffer.push6 a1 a2 a3 a4 a5 a6 s1 => {
        | ? s2 := ? Triple Green (Only_end s2) Empty } } };
only_of_right (a1, a2, a3, a4, a5, a6) (Triple reg (Right_st coloring p s) child)
  with buffer.push6 a1 a2 a3 a4 a5 a6 p => {
    | ? p1 := ? Triple reg (Only_st (adapt_to_prefix coloring) p1 s) child }.

Equations adapt_to_suffix {qp qs q C} :
  coloring qp qs C -> coloring qp (3 + q) C :=
adapt_to_suffix G := G;
adapt_to_suffix Y := Y;
adapt_to_suffix O := O;
adapt_to_suffix R := R.

Equations only_of_left {A lvl C}
  (tl : triple A lvl Left C)
  (six : six_stored_triple A lvl) :
  { t : triple A lvl Only C |
    triple_seq t = triple_seq tl ++ six_stored_triple_seq six } :=
only_of_left (Triple Green (Left_end p s) Empty) (a6, a5, a4, a3, a2, a1)
  with buffer.two s => {
    | ? (a8, a7) with buffer.inject2 p a8 a7 => {
      | ? p1 with buffer.inject6 p1 a6 a5 a4 a3 a2 a1 => {
        | ? p2 := ? Triple Green (Only_end p2) Empty } } };
only_of_left (Triple reg (Left_st coloring p s) child) (a6, a5, a4, a3, a2, a1)
  with buffer.inject6 s a6 a5 a4 a3 a2 a1 => {
    | ? s1 := ? Triple reg (Only_st (adapt_to_suffix coloring) p s1) child }.

Equations pop_pair_green {A lvl}
  (c : chain A lvl Pair Only Not_end green green) :
  { '(a1, sd) : stored_triple A lvl * semi_deque A lvl |
    chain_seq c = stored_triple_seq a1 ++ semi_deque_seq sd } :=
pop_pair_green (Pair_chain cl cr) with triple_of_chain cl => {
  | ? tl with pop_left_green tl => {
    | ? (a1, Six_elements six) with triple_of_chain cr => {
      | ? tr with only_of_right six tr => {
        | ? t with chain_of_triple t => {
          | ? c := ? (a1, Semi c) } } };
    | ? (a1, Ok_pt tl1) with chain_of_triple tl1 => {
      | ? cl1 := ? (a1, Semi (Pair_chain cl1 cr)) } } }.

#[local] Obligation Tactic :=
  try first [ done |
    intros; cbn in *;
    try unfold prefix_seq, suffix_seq, buffer_seq;
    hauto db:rassoc,rlist ].

Equations eject_pair_green {A lvl}
  (c : chain A lvl Pair Only Not_end green green) :
  { '(sd, a1) : semi_deque A lvl * stored_triple A lvl |
    chain_seq c = semi_deque_seq sd ++ stored_triple_seq a1 } :=
eject_pair_green (Pair_chain cl cr) with triple_of_chain cr => {
  | ? tr with eject_right_green tr => {
    | ? (Six_elements six, a1) with triple_of_chain cl => {
      | ? tl with only_of_left tl six => {
        | ? t with chain_of_triple t => {
          | ? c := ? (Semi c, a1) } } };
    | ? (Ok_pt tr1, a1) with chain_of_triple tr1 => {
      | ? cr1 := ? (Semi (Pair_chain cl cr1), a1) } } }.

Local Ltac rewrite_seq :=
  repeat
  match goal with
  | H : seq _ = _ |- _ => rewrite H
  end.

#[local] Obligation Tactic :=
  cbn; intros;
  autorewrite with rlist in *; cbn;
  unfold prefix_seq, suffix_seq, buffer_seq in *.

Equations sandwich_pair_green {A lvl}
  (c : chain A lvl Pair Only Not_end green green) :
  { s : sandwich (stored_triple A lvl) (semi_deque A lvl) |
    chain_seq c = sandwich_seq stored_triple_seq semi_deque_seq s } :=
sandwich_pair_green (Pair_chain cl cr)
  with triple_of_chain cl, triple_of_chain cr => {
    | ? tl, ? tr with pop_left_green tl, eject_right_green tr => {
      | ? (a1, Six_elements (a2, a3, a4, a5, a6, a7)),
        ? (Six_elements (z7, z6, z5, z4, z3, z2), z1) with buffer.empty => {
        | ? b with buffer.push6 a2 a3 a4 a5 a6 a7 b => {
          | ? b1 with buffer.inject6 b1 z7 z6 z5 z4 z3 z2 => { | ? b2 :=
            ? Sandwich
              a1
              (Semi (Only_chain Green_chain (Packet Hole (Only_end b2)) Empty))
              z1 } } };
      | ? (a1, Six_elements six), ? (Ok_pt tr1, z1)
        with only_of_right six tr1 => {
          | ? t with chain_of_triple t => {
            | ? c := ? Sandwich a1 (Semi c) z1 } };
      | ? (a1, Ok_pt tl1), ? (Six_elements six, z1)
        with only_of_left tl1 six => {
          | ? t with chain_of_triple t => {
            | ? c := ? Sandwich a1 (Semi c) z1 } };
      | ? (a1, Ok_pt tl1), ? (Ok_pt tr1, z1)
        with chain_of_triple tl1, chain_of_triple tr1 => {
          | ? cl1, ? cr1 :=
            ? Sandwich a1 (Semi (Pair_chain cl1 cr1)) z1 } } }.
Next Obligation.
  rewrite_seq.
  rewrite <-e, <-e0.
  hauto db:lassoc,rlist.
Qed.
Next Obligation.
  rewrite <-e, <-e0.
  hauto db:lassoc,rlist.
Qed.
Next Obligation.
  rewrite <-e, <-e0.
  hauto db:lassoc,rlist.
Qed.
Next Obligation.
  rewrite <-e, <-e0.
  hauto db:lassoc,rlist.
Qed.

#[local] Obligation Tactic :=
  try first [ done |
    intros; cbn in *;
    try unfold prefix_seq, suffix_seq, buffer_seq;
    hauto db:rassoc,rlist ].

Equations pop_green {A lvl pk} (c : chain A lvl pk Only Not_end green green) :
  { '(a1, sd) : stored_triple A lvl * semi_deque A lvl |
    chain_seq c = stored_triple_seq a1 ++ semi_deque_seq sd } :=
pop_green (pk := Only) c with triple_of_chain c => {
  | ? t with pop_only_green t => {
    | ? (a1, Zero_element) := ? (a1, Semi Empty)
    | ? (a1, Ok_pt t1) with chain_of_triple t1 => {
      | ? c1 := ? (a1, Semi c1) } } };
pop_green (pk := Pair) c with pop_pair_green c => { | ? res := ? res }.

Equations eject_green {A lvl pk} (c : chain A lvl pk Only Not_end green green) :
  { '(sd, a1) : semi_deque A lvl * stored_triple A lvl |
    chain_seq c = semi_deque_seq sd ++ stored_triple_seq a1 } :=
eject_green (pk := Only) c with triple_of_chain c => {
  | ? t with eject_only_green t => {
    | ? (Zero_element, a1) := ? (Semi Empty, a1);
    | ? (Ok_pt t1, a1) with chain_of_triple t1 => {
      | ? c1 := ? (Semi c1, a1) } } };
eject_green (pk := Pair) c with eject_pair_green c => { | ? res := ? res }.

Equations sandwich_green {A lvl pk}
  (c : chain A lvl pk Only Not_end green green) :
  { s : sandwich (stored_triple A lvl) (semi_deque A lvl) |
    chain_seq c = sandwich_seq stored_triple_seq semi_deque_seq s } :=
sandwich_green (pk := Only) c with triple_of_chain c => {
  | ? t with sandwich_only_green t => {
    | ? Alone a1 := ? Alone a1;
    | ? Sandwich a1 Zero_element z1 := ? Sandwich a1 (Semi Empty) z1;
    | ? Sandwich a1 (Ok_pt t1) z1 with chain_of_triple t1 => {
      | ? c1 := ? Sandwich a1 (Semi c1) z1 } } };
sandwich_green (pk := Pair) c with sandwich_pair_green c => {
  | ? res := ? res }.

Equations make_green_prefix {A lvl q qstored}
  (p : prefix A lvl (5 + q))
  (pstored : prefix A lvl (3 + qstored))
  (child : semi_deque A (S lvl)) :
  { '(pgreen, child') : green_buffer A lvl * semi_deque A (S lvl) |
    green_buffer_seq pgreen ++ semi_deque_seq child' =
    prefix_seq p ++ prefix_seq pstored ++ semi_deque_seq child } :=
make_green_prefix p pstored child with buffer.has3p pstored => {
  | ? ((a1, a2, a3), inl v) with buffer.inject3 p a1 a2 a3 => {
    | ? pgreen with buffer.inject_vector pgreen v => {
      | ? pgreen1 := ? (Gbuf pgreen1, child) } };
  | ? ((a1, a2, a3), inr pstored1) with buffer.inject3 p a1 a2 a3 => {
    | ? pgreen with push_semi (Small pstored1) child => {
      | ? child1 := ? (Gbuf pgreen, child1) } } }.

Equations make_green_suffix {A lvl q qstored}
  (child : semi_deque A (S lvl))
  (sstored : suffix A lvl (3 + qstored))
  (s : suffix A lvl (5 + q)) :
  { '(child', sgreen) : semi_deque A (S lvl) * green_buffer A lvl |
    semi_deque_seq child' ++ green_buffer_seq sgreen =
    semi_deque_seq child ++ suffix_seq sstored ++ suffix_seq s } :=
make_green_suffix child sstored s with buffer.has3s sstored => {
  | ? (inl v, (a3, a2, a1)) with buffer.push3 a3 a2 a1 s => {
    | ? sgreen with buffer.push_vector v sgreen => {
      | ? sgreen1 := ? (child, Gbuf sgreen1) } };
  | ? (inr sstored1, (a3, a2, a1)) with buffer.push3 a3 a2 a1 s => {
    | ? sgreen with inject_semi child (Small sstored1) => {
      | ? child1 := ? (child1, Gbuf sgreen) } } }.

Equations extract_prefix {A lvl}
  (stored : stored_triple A (S lvl))
  (child : semi_deque A (S lvl)) :
  { '(pstored, child') : stored_buffer A lvl * semi_deque A (S lvl) |
    stored_buffer_seq pstored ++ semi_deque_seq child' =
    stored_triple_seq stored ++ semi_deque_seq child } :=
extract_prefix (Small p) child := ? (Sbuf p, child);
extract_prefix (Big p schild s) child with push_semi (Small s) child => {
    | ? child1 with concat_semi (Semi schild) child1 => {
      | ? child2 := ? (Sbuf p, child2) } }.

Equations extract_suffix {A lvl}
  (child : semi_deque A (S lvl))
  (stored : stored_triple A (S lvl)) :
  { '(child', sstored) : semi_deque A (S lvl) * stored_buffer A lvl |
    semi_deque_seq child' ++ stored_buffer_seq sstored =
    semi_deque_seq child ++ stored_triple_seq stored } :=
extract_suffix child (Small s) := ? (child, Sbuf s);
extract_suffix child (Big p schild s) with inject_semi child (Small p) => {
  | ? child1 with concat_semi child1 (Semi schild) => {
    | ? child2 := ? (child2, Sbuf s) } }.

Equations ensure_green_prefix {A lvl q pk}
  (p : prefix A lvl (5 + q))
  (child : chain A (S lvl) pk Only Not_end green green) :
  { '(pgreen, child') : green_buffer A lvl * semi_deque A (S lvl) |
    prefix_seq p ++ chain_seq child =
    green_buffer_seq pgreen ++ semi_deque_seq child' } :=
ensure_green_prefix p child with pop_green child => {
  | ? (stored, child1) with extract_prefix stored child1 => {
    | ? (Sbuf pstored, child2) with make_green_prefix p pstored child2 => {
      | ? res := ? res } } }.

#[local] Obligation Tactic :=
  try first [ done |
    intros; cbn in *;
    try unfold prefix_seq, suffix_seq, buffer_seq;
    hauto db:lassoc,rlist ].

Equations ensure_green_suffix {A lvl q pk}
  (child : chain A (S lvl) pk Only Not_end green green)
  (s : suffix A lvl (5 + q)) :
  { '(child', sgreen) : semi_deque A (S lvl) * green_buffer A lvl |
    chain_seq child ++ suffix_seq s =
    semi_deque_seq child' ++ green_buffer_seq sgreen } :=
ensure_green_suffix child s with eject_green child => {
  | ? (child1, stored) with extract_suffix child1 stored => {
    | ? (child2, Sbuf sstored) with make_green_suffix child2 sstored s => {
      | ? res := ? res } } }.

Equations ensure_green_left {A hlvl tlvl hk pk}
  (bd : body A hlvl tlvl hk Left)
  (red : storage A tlvl Left Not_end red)
  (child : chain A (S tlvl) pk Only Not_end green green) :
  { c : chain A hlvl Only hk Not_end green green |
    chain_seq c = body_left_seq bd ++ storage_left_seq red ++
    chain_seq child ++ storage_right_seq red ++ body_right_seq bd } :=
ensure_green_left bd (Left_st R p s) child
  with ensure_green_prefix p child => {
    | ? (Gbuf p1, Semi (e := Is_end) Empty) :=
      ? Only_chain Green_chain (Packet bd (Left_end p1 s)) Empty;
    | ? (Gbuf p1, Semi (e := Not_end) child1) :=
      ? Only_chain Green_chain (Packet bd (Left_st G p1 s)) child1 }.
Next Obligation.
  cbn; intros.
  autorewrite with rlist in *; cbn.
  unfold prefix_seq in *.
  rewrite <-y.
  hauto db:rassoc,rlist.
Qed.
Next Obligation.
  cbn; intros.
  autorewrite with rlist; cbn.
  unfold prefix_seq.
  aac_rewrite <-y.
  hauto db:rassoc,rlist.
Qed.

Equations ensure_green_right {A hlvl tlvl hk pk}
  (bd : body A hlvl tlvl hk Right)
  (red : storage A tlvl Right Not_end red)
  (child : chain A (S tlvl) pk Only Not_end green green) :
  { c : chain A hlvl Only hk Not_end green green |
    chain_seq c = body_left_seq bd ++ storage_left_seq red ++
    chain_seq child ++ storage_right_seq red ++ body_right_seq bd } :=
ensure_green_right bd (Right_st R p s) child
  with ensure_green_suffix child s => {
    | ? (Semi (e := Is_end) Empty, Gbuf s1) :=
      ? Only_chain Green_chain (Packet bd (Right_end p s1)) Empty;
    | ? (Semi (e := Not_end) child1, Gbuf s1) :=
      ? Only_chain Green_chain (Packet bd (Right_st G p s1)) child1 }.
Next Obligation.
  cbn; intros.
  autorewrite with rlist in *; cbn.
  unfold suffix_seq in *.
  rewrite <-y.
  hauto db:lassoc,rlist.
Qed.
Next Obligation.
  cbn; intros.
  autorewrite with rlist; cbn.
  unfold suffix_seq.
  aac_rewrite <-y.
  hauto db:lassoc,rlist.
Qed.

Equations make_green_only {A hlvl tlvl hk qp qs}
  (bd : body A hlvl tlvl hk Only)
  (p : prefix A tlvl (8 + qp))
  (child : semi_deque A (S tlvl))
  (s : prefix A tlvl (8 + qs)) :
  { c : chain A hlvl Only hk Not_end green green |
    chain_seq c = body_left_seq bd ++ prefix_seq p ++
    semi_deque_seq child ++ suffix_seq s ++ body_right_seq bd } :=
make_green_only bd p (Semi (e := Is_end) Empty) s with buffer.has3p8 s => {
  | ? inl ((a1, a2, a3, a4, a5, a6, a7, a8), v)
    with buffer.inject8 p a1 a2 a3 a4 a5 a6 a7 a8 => {
      | ? p1 with buffer.inject_vector p1 v => {
        | ? p2 :=
          ? Only_chain Green_chain (Packet bd (Only_end p2)) Empty } };
  | ? inr (small, s1) with single_chain (Small small) => {
    | ? child :=
      ? Only_chain Green_chain (Packet bd (Only_st G p s1)) child } };
make_green_only bd p (Semi (e := Not_end) child) s :=
  ? Only_chain Green_chain (Packet bd (Only_st G p s)) child.
Next Obligation.
  cbn; intros.
  autorewrite with rlist in *; cbn.
  unfold prefix_seq, suffix_seq, buffer_seq.
  rewrite e1.
  hauto db:rassoc,rlist.
Qed.

#[local] Obligation Tactic :=
  cbn; intros;
  autorewrite with rlist in *; cbn;
  unfold prefix_seq, suffix_seq, buffer_seq in *.

Equations ensure_green_only {A hlvl tlvl hk pk}
  (bd : body A hlvl tlvl hk Only)
  (red : storage A tlvl Only Not_end red)
  (child : chain A (S tlvl) pk Only Not_end green green) :
  { c : chain A hlvl Only hk Not_end green green |
    chain_seq c = body_left_seq bd ++ storage_left_seq red ++
    chain_seq child ++ storage_right_seq red ++ body_right_seq bd } :=
ensure_green_only bd (Only_st R p s) child
  with buffer.has8 p, buffer.has8 s => {
    | ? inl ((a1, a2, a3, a4, a5), vp),
      ? inl ((z5, z4, z3, z2, z1), vs) with sandwich_green child => {
      | ? Alone (Small b)
        with buffer.push_5vector a1 a2 a3 a4 a5 vp b => {
          | ? b1 with buffer.inject_5vector b1 z5 z4 z3 z2 z1 vs => {
            | ? b2 :=
              ? Only_chain Green_chain (Packet bd (Only_end b2)) Empty } };
      | ? Alone (Big p1 child1 s1)
        with buffer.push_5vector a1 a2 a3 a4 a5 vp p1 => {
          | ? p2 with buffer.inject_5vector s1 z5 z4 z3 z2 z1 vs => {
            | ? s2 with make_green_only bd p2 (Semi child1) s2 => {
              | ? res := ? res } } };
      | ? Sandwich storedl child1 storedr
        with extract_prefix storedl child1 => { | ? (Sbuf p1, child2)
          with extract_suffix child2 storedr => { | ? (child3, Sbuf s1)
            with buffer.push_5vector a1 a2 a3 a4 a5 vp p1 => { | ? p2
              with buffer.inject_5vector s1 z5 z4 z3 z2 z1 vs => { | ? s2
                with make_green_only bd p2 child3 s2 => {
                  | ? res := ? res } } } } } };
    | ? inl _, ? inr suf1 with ensure_green_prefix p child => {
      | ? (Gbuf p1, child1) with make_green_only bd p1 child1 suf1 => {
        | ? res := ? res } };
    | ? inr pre1, ? inl _ with ensure_green_suffix child s => {
      | ? (child1, Gbuf s1) with make_green_only bd pre1 child1 s1 => {
        | ? res := ? res } };
    | ? inr p1, ? inr suf :=
      ? Only_chain Green_chain (Packet bd (Only_st G p1 suf)) child }.
Next Obligation.
  rewrite e3 e2.
  hauto db:rassoc,rlist.
Qed.
Next Obligation.
  hauto db:rassoc,rlist.
Qed.
Next Obligation.
  rewrite e0 e1 e4 e3; autorewrite with rlist.
  aac_rewrite y0.
  rewrite e2.
  repeat rewrite map_cons.
  repeat rewrite concat_cons.
  autorewrite with rlist.
  aac_rewrite y.
  hauto db:rassoc,rlist.
Qed.
Next Obligation.
  rewrite e1 e0.
  apply app_inv_head_iff.
  autorewrite with lassoc.
  rewrite y.
  hauto db:rlist.
Qed.
Next Obligation.
  rewrite e1 e.
  autorewrite with lassoc.
  apply app_inv_tail_iff.
  autorewrite with rassoc.
  rewrite y.
  hauto db:rlist.
Qed.
Next Obligation.
  rewrite e e0.
  aac_reflexivity.
Qed.

#[local] Obligation Tactic :=
  try first [ done |
    intros; cbn in *;
    try unfold prefix_seq, suffix_seq, buffer_seq;
    hauto db:lassoc,rlist ].

Equations ensure_green {A lvl pk k e Cl Cr}
  (c : chain A lvl pk k e Cl Cr) :
  { c' : chain A lvl pk k e green green | chain_seq c = chain_seq c' } :=
ensure_green Empty := ? Empty;
ensure_green (Only_chain Green_chain pkt c) := ? Only_chain Green_chain pkt c;
ensure_green (Only_chain Red_chain (Packet bd (Only_st R p s)) c)
  with ensure_green_only bd (Only_st R p s) c => { | ? c' := ? c' };
ensure_green (Only_chain Red_chain (Packet bd (Left_st R p s)) c)
  with ensure_green_left bd (Left_st R p s) c => { | ? c' := ? c' };
ensure_green (Only_chain Red_chain (Packet bd (Right_st R p s)) c)
  with ensure_green_right bd (Right_st R p s) c => { | ? c' := ? c' };
ensure_green (Pair_chain cl cr) with ensure_green cl, ensure_green cr => {
  | ? cl', ? cr' := ? Pair_chain cl' cr' }.