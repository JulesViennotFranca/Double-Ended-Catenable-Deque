Inductive buffer : Type -> color -> Type :=
  | B0 {A : Type} : buffer A red
  | B1 {A : Type} : A -> buffer A yellow
  | B2 {A : Type} : A -> A -> buffer A green
  | B3 {A : Type} : A -> A -> A -> buffer A green
  | B4 {A : Type} : A -> A -> A -> A -> buffer A yellow
  | B5 {A : Type} : A -> A -> A -> A -> A -> buffer A red.
Inductive yellow_buffer (A : Type) : Type :=
  | Yellowish {G Y} :
    buffer A (Mix G Y NoRed) ->
    yellow_buffer A.
Arguments Yellowish {A G Y}.
Inductive any_buffer : Type -> Type :=
  | Any {A C} : buffer A C -> any_buffer A.
Inductive packet : Type -> Type -> color -> Type :=
  | Hole {A : Type} : packet A A uncolored
  | Green_node {A B : Type} {Y : yellow_hue} :
    buffer A green ->
    packet (A * A) B (Mix NoGreen Y NoRed) ->
    buffer A green ->
    packet A B green
  | Yellow_node {A B : Type} {GP GS : green_hue} {YP Y YS : yellow_hue} :
    buffer A (Mix GP YP NoRed) ->
    packet (A * A) B (Mix NoGreen Y NoRed) ->
    buffer A (Mix GS YS NoRed) ->
    packet A B yellow
  | Red_node {A B : Type} {CP CS : color} {Y : yellow_hue} :
    buffer A CP ->
    packet (A * A) B (Mix NoGreen Y NoRed) ->
    buffer A CS ->
    packet A B red.
Inductive regularity : color -> color -> Type :=
  | G {G R} : regularity green (Mix G NoYellow R)
  | Y : regularity yellow green
  | R : regularity red    green.
Inductive chain : Type -> color -> Type :=
  | Ending {A : Type} {C : color} : buffer A C -> chain A green
  | Chain {A B : Type} {C1 C2 : color} :
    regularity C1 C2 -> packet A B C1 -> chain B C2 -> chain A C1.
Inductive decompose : Type -> Type :=
| Underflow {A : Type} : option A -> decompose A
| Ok {A : Type} : buffer A green -> decompose A
| Overflow {A : Type} : buffer A green -> A * A -> decompose A.
Inductive sandwich : Type -> Type :=
| Alone {A : Type} : option A -> sandwich A
| Sandwich {A C} : A -> buffer A C -> A -> sandwich A.
Inductive deque : Type -> Type :=
  | T {A G Y} : chain A (Mix G Y NoRed) -> deque A.

Equations option_seq {A} : option A -> list A :=
option_seq None := [];
option_seq (Some x) := [x].
Equations pair_seq {A} : A * A -> list A :=
pair_seq (x, y) := [x] ++ [y].
Equations buffer_seq {A C} : buffer A C -> list A :=
buffer_seq B0 := [];
buffer_seq (B1 a) := [a];
buffer_seq (B2 a b) := [a] ++ [b];
buffer_seq (B3 a b c) := [a] ++ [b] ++ [c];
buffer_seq (B4 a b c d) := [a] ++ [b] ++ [c] ++ [d];
buffer_seq (B5 a b c d e) := [a] ++ [b] ++ [c] ++ [d] ++ [e].
Equations yellow_buffer_seq {A} : yellow_buffer A -> list A :=
yellow_buffer_seq (Yellowish buf) := buffer_seq buf.
Equations any_buffer_seq {A} : any_buffer A -> list A :=
any_buffer_seq (Any buf) := buffer_seq buf.
Equations flattenp {A} (l : list (A * A)) : list A :=
flattenp [] := [];
flattenp ((x, y) :: l) := [x] ++ [y] ++ flattenp l.
Lemma flattenp_app A (l1: list (A * A)) l2 : flattenp (l1 ++ l2) = flattenp l1 ++ flattenp l2.
Proof.
  induction l1 as [ | (a, b) l].
  - eauto.
  - rewrite <- app_comm_cons.
    simpl.
    rewrite IHl.
    aac_reflexivity.
Qed.
Equations packet_seq {A B C} : packet A B C -> list B -> list A :=
packet_seq Hole l := l;
packet_seq (Green_node p pkt s) l :=
  buffer_seq p ++ flattenp (packet_seq pkt l) ++ buffer_seq s;
packet_seq (Yellow_node p pkt s) l :=
  buffer_seq p ++ flattenp (packet_seq pkt l) ++ buffer_seq s;
packet_seq (Red_node p pkt s) l :=
  buffer_seq p ++ flattenp (packet_seq pkt l) ++ buffer_seq s.
Equations chain_seq {A C} : chain A C -> list A :=
chain_seq (Ending b) := buffer_seq b;
chain_seq (Chain _ pkt cd) := packet_seq pkt (chain_seq cd).
Equations decompose_main_seq {A} : decompose A -> list A :=
decompose_main_seq (Underflow opt) := option_seq opt;
decompose_main_seq (Ok b) := buffer_seq b;
decompose_main_seq (Overflow b _) := buffer_seq b.
Equations decompose_rest_seq {A} : decompose A -> list A :=
decompose_rest_seq (Underflow _) := [];
decompose_rest_seq (Ok _) := [];
decompose_rest_seq (Overflow _ (x, y)) := [x] ++ [y].
Equations sandwich_seq {A} : sandwich A -> list A :=
sandwich_seq (Alone opt) := option_seq opt;
sandwich_seq (Sandwich x b y) := [x] ++ buffer_seq b ++ [y].
Equations deque_seq {A} : deque A -> list A :=
deque_seq (T dq) := chain_seq dq.

Equations green_push {A : Type} (x : A) (b : buffer A green) :
  { b' : yellow_buffer A | yellow_buffer_seq b' = [x] ++ buffer_seq b } :=
green_push x (B2 a b) := ? Yellowish (B3 x a b);
green_push x (B3 a b c) := ? Yellowish (B4 x a b c).
Equations green_inject {A : Type} (b : buffer A green) (x : A) :
  { b' : yellow_buffer A | yellow_buffer_seq b' = buffer_seq b ++ [x] } :=
green_inject (B2 a b) x := ? Yellowish (B3 a b x);
green_inject (B3 a b c) x := ? Yellowish (B4 a b c x).
Equations green_pop {A : Type} (b : buffer A green) :
  { '(x, b') : A * yellow_buffer A |
    buffer_seq b = [x] ++ yellow_buffer_seq b' } :=
green_pop (B2 a b) => ? (a, (Yellowish (B1 b)));
green_pop (B3 a b c) => ? (a, (Yellowish (B2 b c))).
Equations green_eject {A : Type} (b : buffer A green) :
  { '(b', x) : yellow_buffer A * A |
    buffer_seq b = yellow_buffer_seq b' ++ [x] } :=
green_eject (B2 a b) => ? ((Yellowish (B1 a)), b);
green_eject (B3 a b c) => ? ((Yellowish (B2 a b)), c).
Equations yellow_push {A : Type} (x : A) (b : yellow_buffer A) :
  { b' : any_buffer A | any_buffer_seq b' = [x] ++ yellow_buffer_seq b } :=
yellow_push x (Yellowish (B1 a)) := ? Any (B2 x a);
yellow_push x (Yellowish (B2 a b)) := ? Any (B3 x a b);
yellow_push x (Yellowish (B3 a b c)) := ? Any (B4 x a b c);
yellow_push x (Yellowish (B4 a b c d)) := ? Any (B5 x a b c d).
Equations yellow_inject {A : Type} (b : yellow_buffer A) (x : A) :
  { b' : any_buffer A | any_buffer_seq b' = yellow_buffer_seq b ++ [x] } :=
yellow_inject (Yellowish (B1 a)) x := ? Any (B2 a x);
yellow_inject (Yellowish (B2 a b)) x := ? Any (B3 a b x);
yellow_inject (Yellowish (B3 a b c)) x := ? Any (B4 a b c x);
yellow_inject (Yellowish (B4 a b c d)) x := ? Any (B5 a b c d x).
Equations yellow_pop {A : Type} (b : yellow_buffer A) :
  { '(x, b') : A * any_buffer A |
    yellow_buffer_seq b = [x] ++ any_buffer_seq b' } :=
yellow_pop (Yellowish (B1 a)) := ? (a, Any B0);
yellow_pop (Yellowish (B2 a b)) := ? (a, Any (B1 b));
yellow_pop (Yellowish (B3 a b c)) := ? (a, Any (B2 b c));
yellow_pop (Yellowish (B4 a b c d)) := ? (a, Any (B3 b c d)).
Equations yellow_eject {A : Type} (b : yellow_buffer A) :
  { '(b', x) : any_buffer A * A |
    yellow_buffer_seq b = any_buffer_seq b' ++ [x] } :=
yellow_eject (Yellowish (B1 a)) := ? (Any B0, a);
yellow_eject (Yellowish (B2 a b)) := ? (Any (B1 a), b);
yellow_eject (Yellowish (B3 a b c)) := ? (Any (B2 a b), c);
yellow_eject (Yellowish (B4 a b c d)) := ? (Any (B3 a b c), d).
Equations buffer_push {A : Type} {C : color} (x : A) (b : buffer A C) :
  { c : chain A green | chain_seq c = [x] ++ buffer_seq b } :=
buffer_push x B0 := ? Ending (B1 x);
buffer_push x (B1 a) := ? Ending (B2 x a);
buffer_push x (B2 a b) := ? Ending (B3 x a b);
buffer_push x (B3 a b c) := ? Ending (B4 x a b c);
buffer_push x (B4 a b c d) := ? Ending (B5 x a b c d);
buffer_push x (B5 a b c d e) :=
  ? Chain G (Green_node (B3 x a b) Hole (B3 c d e)) (Ending B0).
Equations buffer_inject {A : Type} {C : color} (b : buffer A C) (x : A) :
  { c : chain A green | chain_seq c = buffer_seq b ++ [x] } :=
buffer_inject B0 x := ? Ending (B1 x);
buffer_inject (B1 a) x := ? Ending (B2 a x);
buffer_inject (B2 a b) x := ? Ending (B3 a b x);
buffer_inject (B3 a b c) x := ? Ending (B4 a b c x);
buffer_inject (B4 a b c d) x := ? Ending (B5 a b c d x);
buffer_inject (B5 a b c d e) x :=
  ? Chain G (Green_node (B3 a b c) Hole (B3 d e x)) (Ending B0).
Equations buffer_pop {A C} (b : buffer A C) :
  { o : option (A * any_buffer A) |
    buffer_seq b =
    match o with
    | None => []
    | Some (x, b') => [x] ++ any_buffer_seq b'
    end } :=
buffer_pop B0 := ? None;
buffer_pop (B5 a b c d e) := ? Some (a, Any (B4 b c d e));
buffer_pop buf with yellow_pop (Yellowish buf) => { | ? o := ? Some o }.
Equations buffer_eject {A C} (b : buffer A C) :
  { o : option (any_buffer A * A) |
    buffer_seq b =
    match o with
    | None => []
    | Some (b', x) => any_buffer_seq b' ++ [x]
    end } :=
buffer_eject (B5 a b c d e) := ? Some (Any (B4 a b c d), e);
buffer_eject B0 := ? None;
buffer_eject buf with yellow_eject (Yellowish buf) => { | ? o := ? Some o }.
Equations prefix_rot {A C} (x : A) (b : buffer A C) :
  { '(b', y) : buffer A C * A | [x] ++ buffer_seq b = buffer_seq b' ++ [y] } :=
prefix_rot x B0 := ? (B0, x);
prefix_rot x (B1 a) := ? (B1 x, a);
prefix_rot x (B2 a b) := ? (B2 x a, b);
prefix_rot x (B3 a b c) := ? (B3 x a b, c);
prefix_rot x (B4 a b c d) := ? (B4 x a b c, d);
prefix_rot x (B5 a b c d e) := ? (B5 x a b c d, e).
Equations suffix_rot {A C} (b : buffer A C) (y : A) :
  { '(x, b') : A * buffer A C | buffer_seq b ++ [y] = [x] ++ buffer_seq b' } :=
suffix_rot B0 x := ? (x, B0);
suffix_rot (B1 a) x := ? (a, B1 x);
suffix_rot (B2 a b) x := ? (a, B2 b x);
suffix_rot (B3 a b c) x := ? (a, B3 b c x);
suffix_rot (B4 a b c d) x := ? (a, B4 b c d x);
suffix_rot (B5 a b c d e) x := ? (a, B5 b c d e x).
Equations prefix23 {A} (o : option A) (p : A * A) :
  { b : buffer A green | buffer_seq b = option_seq o ++ pair_seq p } :=
prefix23 None (b, c) := ? B2 b c;
prefix23 (Some a) (b, c) := ? B3 a b c.
Equations suffix23 {A} (p : A * A) (o : option A) :
  { b : buffer A green | buffer_seq b = pair_seq p ++ option_seq o } :=
suffix23 (a, b) None := ? B2 a b;
suffix23 (a, b) (Some c) := ? B3 a b c.
Equations suffix12 {A} (x : A) (o : option A) :
  { b : yellow_buffer A | yellow_buffer_seq b = [x] ++ option_seq o } :=
suffix12 x None := ? Yellowish (B1 x);
suffix12 x (Some y) := ? Yellowish (B2 x y).
Equations prefix_decompose {A C} (b : buffer A C) :
  { dec : decompose A | buffer_seq b = decompose_main_seq dec ++ decompose_rest_seq dec } :=
prefix_decompose B0 := ? Underflow None;
prefix_decompose (B1 x) := ? Underflow (Some x);
prefix_decompose (B2 a b) := ? Ok (B2 a b);
prefix_decompose (B3 a b c) := ? Ok (B3 a b c);
prefix_decompose (B4 a b c d) := ? Overflow (B2 a b) (c, d);
prefix_decompose (B5 a b c d e) := ? Overflow (B3 a b c) (d, e).
Equations suffix_decompose {A C} (b : buffer A C) :
  { dec : decompose A | buffer_seq b = decompose_rest_seq dec ++ decompose_main_seq dec } :=
suffix_decompose B0 := ? Underflow None;
suffix_decompose (B1 x) := ? Underflow (Some x);
suffix_decompose (B2 a b) := ? Ok (B2 a b);
suffix_decompose (B3 a b c) := ? Ok (B3 a b c);
suffix_decompose (B4 a b c d) := ? Overflow (B2 c d) (a, b);
suffix_decompose (B5 a b c d e) := ? Overflow (B3 c d e) (a, b).
Equations buffer_unsandwich {A C} (b : buffer A C) :
  { sw : sandwich A | buffer_seq b = sandwich_seq sw } :=
buffer_unsandwich B0 := ? Alone None;
buffer_unsandwich (B1 a) := ? Alone (Some a);
buffer_unsandwich (B2 a b) := ? Sandwich a B0 b;
buffer_unsandwich (B3 a b c) := ? Sandwich a (B1 b) c;
buffer_unsandwich (B4 a b c d) := ? Sandwich a (B2 b c) d;
buffer_unsandwich (B5 a b c d e) := ? Sandwich a (B3 b c d) e.
Equations buffer_halve {A C} (b : buffer A C) :
  { '(o, b') : option A * any_buffer (A * A) |
    buffer_seq b = option_seq o ++ flattenp (any_buffer_seq b') } :=
buffer_halve B0 := ? (None, Any B0);
buffer_halve (B1 a) := ? (Some a, Any B0);
buffer_halve (B2 a b) := ? (None, Any (B1 (a, b)));
buffer_halve (B3 a b c) := ? (Some a, Any (B1 (b, c)));
buffer_halve (B4 a b c d) := ? (None, Any (B2 (a, b) (c, d)));
buffer_halve (B5 a b c d e) := ? (Some a, Any (B2 (b, c) (d, e))).
Equations green_prefix_concat {A C}
  (buf1 : buffer A C)
  (buf2 : buffer (A * A) green) :
  { '(buf1', buf2') : buffer A green * yellow_buffer (A * A) |
    buffer_seq buf1 ++ flattenp (buffer_seq buf2) =
    buffer_seq buf1' ++ flattenp (yellow_buffer_seq buf2') } :=
green_prefix_concat buf1 buf2 with prefix_decompose buf1 => {
  | (? Ok buf) => ? (buf, Yellowish buf2);
  | (? Underflow opt) with green_pop buf2 => {
    | (? (ab, buf)) =>
        let '(? prefix) := prefix23 opt ab in
        ? (prefix, buf) };
  | (? Overflow buf ab) =>
    let '(? suffix) := green_push ab buf2 in
    ? (buf, suffix)
}.
Equations green_suffix_concat {A C}
  (buf1 : buffer (A * A) green)
  (buf2 : buffer A C) :
  { '(buf1', buf2') : yellow_buffer (A * A) * buffer A green |
    flattenp (buffer_seq buf1) ++ buffer_seq buf2 =
    flattenp (yellow_buffer_seq buf1') ++ buffer_seq buf2' } :=
green_suffix_concat buf1 buf2 with suffix_decompose buf2 => {
  | ? Ok buf => ? (Yellowish buf1, buf);
  | ? Underflow opt with green_eject buf1 => {
    | ? (buf, ab) =>
        let '(? suffix) := suffix23 ab opt in
        ? (buf, suffix) };
  | ? Overflow buf ab =>
    let '(? prefix) := green_inject buf1 ab in
    ? (prefix, buf)
}.
Equations yellow_prefix_concat {A B}
  (buf1 : buffer A B)
  (buf2 : yellow_buffer (A * A)) :
  { '(buf1', buf2') : buffer A green * any_buffer (A * A) |
    buffer_seq buf1 ++ flattenp (yellow_buffer_seq buf2) =
    buffer_seq buf1' ++ flattenp (any_buffer_seq buf2') } :=
yellow_prefix_concat buf1 buf2 with prefix_decompose buf1 => {
  | ? (Ok buf) =>
    let '(Yellowish buf2) := buf2 in
    ? (buf, Any buf2);
  | ? (Underflow opt) with yellow_pop buf2 => {
    | ? (ab, buf) =>
      let '(? prefix) := prefix23 opt ab in
      ? (prefix, buf) };
  | ? (Overflow buf ab) =>
    let '(? suffix) := yellow_push ab buf2 in
    ? (buf, suffix)
}.
Equations yellow_suffix_concat {A B}
  (buf1 : yellow_buffer (A * A))
  (buf2 : buffer A B) :
  { '(buf1', buf2') : any_buffer (A * A) * buffer A green |
    flattenp (yellow_buffer_seq buf1) ++ buffer_seq buf2 =
    flattenp (any_buffer_seq buf1') ++ buffer_seq buf2' } :=
yellow_suffix_concat buf1 buf2 with suffix_decompose buf2 => {
  | ? (Ok buf) =>
    let '(Yellowish buf1) := buf1 in
    ? (Any buf1, buf);
  | ? (Underflow opt) with yellow_eject buf1 => {
    | ? (buf, ab) =>
      let '(? suffix) := suffix23 ab opt in
      ? (buf, suffix) };
  | ? (Overflow buf ab) =>
    let '(? prefix) := yellow_inject buf1 ab in
    ? (prefix, buf)
}.
Equations chain_of_opt3 {A}
  (o1 : option A) (o2 : option (A * A)) (o3 : option A) :
  { cd : chain A green |
    chain_seq cd =
      option_seq o1 ++ flattenp (option_seq o2) ++ option_seq o3 } :=
chain_of_opt3 None None None := ? Ending B0;
chain_of_opt3 (Some a) None None := ? Ending (B1 a);
chain_of_opt3 None None (Some a) := ? Ending (B1 a);
chain_of_opt3 (Some a) None (Some b) := ? Ending (B2 a b);
chain_of_opt3 None (Some (a, b)) None := ? Ending (B2 a b);
chain_of_opt3 (Some a) (Some (b, c)) None := ? Ending (B3 a b c);
chain_of_opt3 None (Some (a, b)) (Some c) := ? Ending (B3 a b c);
chain_of_opt3 (Some a) (Some (b, c)) (Some d) := ? Ending (B4 a b c d).
Local Ltac flattenp_lists :=
  repeat
  match goal with
  | ab : ?A * ?A |- _ => destruct ab; cbn in *
  end;
  match goal with
  | H : _ ++ [(_, _)] = _ |- _ =>
    apply (f_equal flattenp) in H;
    rewrite !flattenp_app in H;
    cbn in H;
    try aac_rewrite H;
    try aac_rewrite <- H
  | H : [(_, _)] ++ _ = _ |- _ =>
    apply (f_equal flattenp) in H;
    rewrite !flattenp_app in H;
    cbn in H;
    try aac_rewrite H;
    try aac_rewrite <- H
  end.
Equations make_small {A C1 C2 C3}
  (b1 : buffer A C1) (b2 : buffer (A * A) C2) (b3 : buffer A C3) :
  { c : chain A green |
    chain_seq c =
      buffer_seq b1 ++ flattenp (buffer_seq b2) ++ buffer_seq b3 } :=
make_small prefix1 buf suffix1
  with (prefix_decompose prefix1), (suffix_decompose suffix1) => {
    | (? Underflow p1), (? Underflow s1) with buffer_unsandwich buf => {
      | ? Sandwich ab rest cd with prefix23 p1 ab, suffix23 cd s1 => {
        | ? prefix, ? suffix :=
          ? Chain G (Green_node prefix Hole suffix) (Ending rest) };
      | ? Alone opt with chain_of_opt3 p1 opt s1 => { | ? cd := ? cd } };
    | (? Underflow opt), (? Ok s1) with buffer_pop buf => {
      | ? None with opt => {
        | None := ? Ending s1;
        | Some x with buffer_push x s1 => { | ? cd := ? cd } };
      | ? Some (cd, Any rest) with prefix23 opt cd => {
        | ? prefix := ? Chain G (Green_node prefix Hole s1) (Ending rest) } };
    | (? Underflow opt), (? Overflow s1 ab) with suffix_rot buf ab => {
      | ? (cd, center) with prefix23 opt cd => {
        | ? prefix => ? Chain G (Green_node prefix Hole s1) (Ending center) } };
    | (? Ok p1), (? Underflow opt) with buffer_eject buf => {
      | ? None with opt => {
        | None := ? Ending p1;
        | Some x with buffer_inject p1 x => { | ? cd := ? cd } };
      | ? Some (Any rest, cd) with suffix23 cd opt => {
        | ? suffix := ? Chain G (Green_node p1 Hole suffix) (Ending rest) } };
    | (? Ok p1), (? Ok s1) :=
      ? Chain G (Green_node p1 Hole s1) (Ending buf);
    | (? Ok p1), (? Overflow s1 ab) with buffer_inject buf ab => {
      | ? rest => ? Chain G (Green_node p1 Hole s1) rest };
    | (? Overflow p1 ab), (? Underflow opt) with prefix_rot ab buf => {
      | ? (center, cd) with suffix23 cd opt => {
        | ? suffix => ? Chain G (Green_node p1 Hole suffix) (Ending center) } };
    | (? Overflow p1 ab), (? Ok s1) with buffer_push ab buf => {
      | ? rest => ? Chain G (Green_node p1 Hole s1) rest };
    | (? Overflow p1 ab), (? Overflow s1 cd) with buffer_halve buf => {
      | ? (x, Any rest) with suffix12 ab x => {
        | ? Yellowish prefix =>
          ? Chain G (Green_node p1
                    (Yellow_node prefix Hole (B1 cd)) s1) (Ending rest) } } }.
Next Obligation.
  cbn. intros * Hpref1 * Hpref * Hcenter * Hsuff1.
  rewrite Hpref.
  rewrite Hsuff1.
  flattenp_lists.
  hauto db:rlist.
Qed.
Next Obligation.
  cbn. intros * Hpref1 * Hcenter * Hsuff * Hsuff1.
  rewrite Hpref1.
  rewrite Hsuff.
  flattenp_lists.
  hauto db:rlist.
Qed.
Equations green_of_red {A : Type} (c : chain A red) :
  { c' : chain A green | chain_seq c' = chain_seq c } :=
green_of_red (Chain R (Red_node p1 Hole s1) (Ending buf))
  with make_small p1 buf s1 => { | ? c' := ? c' };
green_of_red (Chain R (Red_node p1 (Yellow_node p2 child s2) s1) c)
  with yellow_prefix_concat p1 (Yellowish p2),
       yellow_suffix_concat (Yellowish s2) s1 => {
  | ? (p1', Any p2'), ? (Any s2', s1') :=
    ? Chain G (Green_node p1' Hole s1') (Chain R (Red_node p2' child s2') c) };
green_of_red (Chain R (Red_node p1 Hole s1)
             (Chain G (Green_node p2 child s2) c))
  with green_prefix_concat p1 p2, green_suffix_concat s2 s1 => {
  | ? (p1', Yellowish p2'), ? (Yellowish s2', s1') :=
    ? Chain G (Green_node p1' (Yellow_node p2' child s2') s1') c }.
Next Obligation.
  cbn. intros * H1 * H2 *. autorewrite with rlist.
  rewrite !app_assoc H1. hauto db:rlist.
Qed.
Next Obligation.
  cbn. intros * H1 * H2 *. autorewrite with rlist.
  rewrite !app_assoc H1. hauto db:rlist.
Qed.
Equations ensure_green {A G R} (c : chain A (Mix G NoYellow R)) :
  { c' : chain A green | chain_seq c' = chain_seq c } :=
ensure_green (Ending buf) := ? Ending buf;
ensure_green (Chain G pkt c) := ? Chain G pkt c;
ensure_green (Chain R pkt c) := green_of_red (Chain R pkt c).
Equations make_yellow {A B: Type} {G1 Y1 Y2 G3 Y3 G4 R4}
  (buf1 : buffer A (Mix G1 Y1 NoRed))
  (pkt : packet (A * A) B (Mix NoGreen Y2 NoRed))
  (buf2 : buffer A (Mix G3 Y3 NoRed))
  (c : chain B (Mix G4 NoYellow R4)) :
  { d : deque A |
    deque_seq d = buffer_seq buf1 ++
                  flattenp (packet_seq pkt (chain_seq c)) ++
                  buffer_seq buf2 } :=
make_yellow p1 child s1 c with ensure_green c => {
  | ? c' => ? T (Chain Y (Yellow_node p1 child s1) c') }.
Equations make_red {A B: Type} {C1 Y2 C3}
  (buf1 : buffer A C1)
  (pkt : packet (A * A) B (Mix NoGreen Y2 NoRed))
  (buf2 : buffer A C3)
  (c : chain B green) :
  { d : deque A |
    deque_seq d = buffer_seq buf1 ++
                  flattenp (packet_seq pkt (chain_seq c)) ++
                  buffer_seq buf2 } :=
make_red p1 child s1 cd
  with green_of_red (Chain R (Red_node p1 child s1) cd) => {
    | ? cd' => ? T cd' }.
Equations push {A: Type} (x : A) (d : deque A) :
  { d' : deque A | deque_seq d' = [x] ++ deque_seq d } :=
push x (T (Ending buf)) with buffer_push x buf => {
  | ? buf' => ? T buf' };
push x (T (Chain G (Green_node p1 child s1) c)) with green_push x p1 => {
  | ? Yellowish buf' with make_yellow buf' child s1 c => {
    | ? d' => ? d' } };
push x (T (Chain Y (Yellow_node p1 child s1) c))
  with yellow_push x (Yellowish p1) => {
  | ? (Any p1') with make_red p1' child s1 c => {
    | ? d' => ? d' } }.
Equations inject {A: Type} (d : deque A) (x : A) :
  { d' : deque A | deque_seq d' = deque_seq d ++ [x] } :=
inject (T (Ending buf)) x with buffer_inject buf x => {
  | ? buf' => ? T buf' };
inject (T (Chain G (Green_node p1 child s1) c)) x with green_inject s1 x => {
  | ? Yellowish buf' with make_yellow p1 child buf' c => {
    | ? d' => ? d' } };
inject (T (Chain Y (Yellow_node p1 child s1) c)) x
  with yellow_inject (Yellowish s1) x => {
  | ? (Any s1') with make_red p1 child s1' c => {
    | ? d' => ? d' } }.
Equations pop {A: Type} (d : deque A) :
  { o : option (A * deque A) |
    deque_seq d = match o with
                  | None => []
                  | Some (x, d') => [x] ++ deque_seq d'
                  end } :=
pop (T (Ending buf)) with buffer_pop buf => {
  pop _ (? None) := ? None;
  pop _ (? Some (x, Any buf')) := ? Some (x, T (Ending buf')) };
pop (T (Chain G (Green_node p1 child s1) c)) with green_pop p1 => {
  | ? (x, Yellowish p1') with make_yellow p1' child s1 c => {
    | ? d' => ? Some (x, d') } };
pop (T (Chain Y (Yellow_node p1 child s1) c))
  with yellow_pop (Yellowish p1) => {
    | ? (x, Any p1') with make_red p1' child s1 c => {
      | ? d' => ? Some (x, d') } }.
Equations eject {A : Type} (d : deque A) :
  { o : option (deque A * A) |
    deque_seq d = match o with
                  | None => []
                  | Some (d', x) => deque_seq d' ++ [x]
                  end } :=
eject (T (Ending buf)) with buffer_eject buf => {
  eject _ (? None) := ? None;
  eject _ (? Some (Any buf', x)) := ? Some (T (Ending buf'), x) };
eject (T (Chain G (Green_node p1 child s1) c)) with green_eject s1 => {
  | ? (Yellowish s1', x) with make_yellow p1 child s1' c => {
    | ? d' => ? Some (d', x) } };
eject (T (Chain Y (Yellow_node p1 child s1) c))
  with yellow_eject (Yellowish s1) => {
    | ? (Any s1', x) with make_red p1 child s1' c => {
      | ? d' => ? Some (d', x) } }.