From Coq Require Import ssreflect.
From Coq Require Import Program List ZArith Lia.
Import ListNotations.
From Equations Require Import Equations.
From Hammer Require Import Tactics.
From AAC_tactics Require Import AAC.
From AAC_tactics Require Import Instances.
Import Instances.Lists.

From Color Require Import color.
Import GYR.

(* Types *)

(* In the following types, an integer parameter is introduced : the [lvl] of
   the type. The level contains information on the type of elements stored in
   the structure encoded. As elements stored in our different structure are
   iterated pairs of a type A, the level is simply the number of times we
   iterated the product on A.

   For example, a buffer of level 0 will contain elements of A, a buffer of
   level 1 will contain elements of A * A, a buffer of level 2 will contain
   elements of (A * A) * (A * A), and so on ... *)

(* A type for leveled buffers. *)

Inductive buffer : Type -> color -> Type :=
  | B0 {A : Type} : buffer A red
  | B1 {A : Type} : A -> buffer A yellow
  | B2 {A : Type} : A -> A -> buffer A green
  | B3 {A : Type} : A -> A -> A -> buffer A green
  | B4 {A : Type} : A -> A -> A -> A -> buffer A yellow
  | B5 {A : Type} : A -> A -> A -> A -> A -> buffer A red.

(* A type for yellow buffers. *)

Inductive yellow_buffer (A : Type) : Type :=
  | Yellowish {G Y} :
    buffer A (Mix G Y NoRed) ->
    yellow_buffer A.
Arguments Yellowish {A G Y}.

(* A type for any buffers. *)

Inductive any_buffer : Type -> Type :=
  | Any {A C} : buffer A C -> any_buffer A.

Inductive packet : Type -> Type -> color -> Type :=
  | Hole {A : Type} : packet A A uncolored
  | Green_node {A B : Type} {Y : yellow_hue} :
    buffer A green ->
    packet (A * A) B (Mix NoGreen Y NoRed) ->
    buffer A green ->
    packet A B green
  | Yellow_node {A B : Type} {GP GS : green_hue} {YP Y YS : yellow_hue} :
    buffer A (Mix GP YP NoRed) ->
    packet (A * A) B (Mix NoGreen Y NoRed) ->
    buffer A (Mix GS YS NoRed) ->
    packet A B yellow
  | Red_node {A B : Type} {CP CS : color} {Y : yellow_hue} :
    buffer A CP ->
    packet (A * A) B (Mix NoGreen Y NoRed) ->
    buffer A CS ->
    packet A B red.

Inductive regularity : color -> color -> Type :=
  | G {G R} : regularity green (Mix G NoYellow R)
  | Y : regularity yellow green
  | R : regularity red    green.

Inductive chain : Type -> color -> Type :=
  | Ending {A : Type} {C : color} : buffer A C -> chain A green
  | Chain {A B : Type} {C1 C2 : color} :
    regularity C1 C2 -> packet A B C1 -> chain B C2 -> chain A C1.

(* The leveled decompose type. *)

Inductive decompose : Type -> Type :=
| Underflow {A : Type} : option A -> decompose A
| Ok {A : Type} : buffer A green -> decompose A
| Overflow {A : Type} : buffer A green -> A * A -> decompose A.

(* The leveled sandwich type. *)

Inductive sandwich : Type -> Type :=
| Alone {A : Type} : option A -> sandwich A
| Sandwich {A C} : A -> buffer A C -> A -> sandwich A.

Inductive deque : Type -> Type :=
  | T {A G Y} : chain A (Mix G Y NoRed) -> deque A.

(* Models *)

Set Equations Transparent.

Opaque app.
Definition singleton {A : Type} (x : A) : list A := [x].
Opaque singleton.

(* A list of tactics to be used when trying to resolve obligations generated by
   Equations. *)

#[export] Hint Rewrite <-app_assoc : rlist.
#[export] Hint Rewrite <-app_comm_cons : rlist.
#[export] Hint Rewrite app_nil_r : rlist.

(* Returns the sequence contained in an option. *)

Equations option_seq {A} : option A -> list A :=
option_seq None := [];
option_seq (Some x) := [x].

Equations pair_seq {A} : A * A -> list A :=
pair_seq (x, y) := [x] ++ [y].

(* Returns the sequence contained in a buffer. *)

Equations buffer_seq {A C} : buffer A C -> list A :=
buffer_seq B0 := [];
buffer_seq (B1 a) := [a];
buffer_seq (B2 a b) := [a] ++ [b];
buffer_seq (B3 a b c) := [a] ++ [b] ++ [c];
buffer_seq (B4 a b c d) := [a] ++ [b] ++ [c] ++ [d];
buffer_seq (B5 a b c d e) := [a] ++ [b] ++ [c] ++ [d] ++ [e].

(* Returns the sequence contained in a yellow buffer. *)

Equations yellow_buffer_seq {A} : yellow_buffer A -> list A :=
yellow_buffer_seq (Yellowish buf) := buffer_seq buf.

(* Returns the sequence contained in any buffer. *)

Equations any_buffer_seq {A} : any_buffer A -> list A :=
any_buffer_seq (Any buf) := buffer_seq buf.

Equations flattenp {A} (l : list (A * A)) : list A :=
flattenp [] := [];
flattenp ((x, y) :: l) := [x] ++ [y] ++ flattenp l.

(* A simple lemma to prove the distributivity of flattenp over concatenation
   of lists. *)

Lemma flattenp_app A (l1: list (A * A)) l2 : flattenp (l1 ++ l2) = flattenp l1 ++ flattenp l2.
Proof.
  induction l1 as [ | (a, b) l].
  - eauto.
  - rewrite <- app_comm_cons.
    simpl.
    rewrite IHl.
    aac_reflexivity.
Qed.

#[export] Hint Rewrite flattenp_app : rlist.

Equations packet_seq {A B C} : packet A B C -> list B -> list A :=
packet_seq Hole l := l;
packet_seq (Green_node p pkt s) l :=
  buffer_seq p ++ flattenp (packet_seq pkt l) ++ buffer_seq s;
packet_seq (Yellow_node p pkt s) l :=
  buffer_seq p ++ flattenp (packet_seq pkt l) ++ buffer_seq s;
packet_seq (Red_node p pkt s) l :=
  buffer_seq p ++ flattenp (packet_seq pkt l) ++ buffer_seq s.

Equations chain_seq {A C} : chain A C -> list A :=
chain_seq (Ending b) := buffer_seq b;
chain_seq (Chain _ pkt cd) := packet_seq pkt (chain_seq cd).

Equations decompose_main_seq {A} : decompose A -> list A :=
decompose_main_seq (Underflow opt) := option_seq opt;
decompose_main_seq (Ok b) := buffer_seq b;
decompose_main_seq (Overflow b _) := buffer_seq b.

(* Returns the sequence of excess elements of an object of type decompose. *)

Equations decompose_rest_seq {A} : decompose A -> list A :=
decompose_rest_seq (Underflow _) := [];
decompose_rest_seq (Ok _) := [];
decompose_rest_seq (Overflow _ (x, y)) := [x] ++ [y].

(* Returns the sequence of elements of an object of type sandwich. *)

Equations sandwich_seq {A} : sandwich A -> list A :=
sandwich_seq (Alone opt) := option_seq opt;
sandwich_seq (Sandwich x b y) := [x] ++ buffer_seq b ++ [y].

(* Returns the sequence contained in a deque. *)

Equations deque_seq {A} : deque A -> list A :=
deque_seq (T dq) := chain_seq dq.

Unset Equations Transparent.

#[local] Obligation Tactic :=
  try first [ done | cbn; hauto db:rlist ].

Notation "? x" := (@exist _ _ x _) (at level 100).

(* Pushing on a green buffer. *)

Equations green_push {A : Type} (x : A) (b : buffer A green) :
  { b' : yellow_buffer A | yellow_buffer_seq b' = [x] ++ buffer_seq b } :=
green_push x (B2 a b) := ? Yellowish (B3 x a b);
green_push x (B3 a b c) := ? Yellowish (B4 x a b c).

(* Injecting on a green buffer. *)

Equations green_inject {A : Type} (b : buffer A green) (x : A) :
  { b' : yellow_buffer A | yellow_buffer_seq b' = buffer_seq b ++ [x] } :=
green_inject (B2 a b) x := ? Yellowish (B3 a b x);
green_inject (B3 a b c) x := ? Yellowish (B4 a b c x).

(* Poping from a green buffer. *)

Equations green_pop {A : Type} (b : buffer A green) :
  { '(x, b') : A * yellow_buffer A |
    buffer_seq b = [x] ++ yellow_buffer_seq b' } :=
green_pop (B2 a b) => ? (a, (Yellowish (B1 b)));
green_pop (B3 a b c) => ? (a, (Yellowish (B2 b c))).

(* Ejecting from a green buffer. *)

Equations green_eject {A : Type} (b : buffer A green) :
  { '(b', x) : yellow_buffer A * A |
    buffer_seq b = yellow_buffer_seq b' ++ [x] } :=
green_eject (B2 a b) => ? ((Yellowish (B1 a)), b);
green_eject (B3 a b c) => ? ((Yellowish (B2 a b)), c).

(* Pushing on a yellow buffer. *)

Equations yellow_push {A : Type} (x : A) (b : yellow_buffer A) :
  { b' : any_buffer A | any_buffer_seq b' = [x] ++ yellow_buffer_seq b } :=
yellow_push x (Yellowish (B1 a)) := ? Any (B2 x a);
yellow_push x (Yellowish (B2 a b)) := ? Any (B3 x a b);
yellow_push x (Yellowish (B3 a b c)) := ? Any (B4 x a b c);
yellow_push x (Yellowish (B4 a b c d)) := ? Any (B5 x a b c d).

(* Injecting on a yellow buffer. *)

Equations yellow_inject {A : Type} (b : yellow_buffer A) (x : A) :
  { b' : any_buffer A | any_buffer_seq b' = yellow_buffer_seq b ++ [x] } :=
yellow_inject (Yellowish (B1 a)) x := ? Any (B2 a x);
yellow_inject (Yellowish (B2 a b)) x := ? Any (B3 a b x);
yellow_inject (Yellowish (B3 a b c)) x := ? Any (B4 a b c x);
yellow_inject (Yellowish (B4 a b c d)) x := ? Any (B5 a b c d x).

(* Poping from a yellow buffer. *)

Equations yellow_pop {A : Type} (b : yellow_buffer A) :
  { '(x, b') : A * any_buffer A |
    yellow_buffer_seq b = [x] ++ any_buffer_seq b' } :=
yellow_pop (Yellowish (B1 a)) := ? (a, Any B0);
yellow_pop (Yellowish (B2 a b)) := ? (a, Any (B1 b));
yellow_pop (Yellowish (B3 a b c)) := ? (a, Any (B2 b c));
yellow_pop (Yellowish (B4 a b c d)) := ? (a, Any (B3 b c d)).

(* Ejecting from a yellow buffer. *)

Equations yellow_eject {A : Type} (b : yellow_buffer A) :
  { '(b', x) : any_buffer A * A |
    yellow_buffer_seq b = any_buffer_seq b' ++ [x] } :=
yellow_eject (Yellowish (B1 a)) := ? (Any B0, a);
yellow_eject (Yellowish (B2 a b)) := ? (Any (B1 a), b);
yellow_eject (Yellowish (B3 a b c)) := ? (Any (B2 a b), c);
yellow_eject (Yellowish (B4 a b c d)) := ? (Any (B3 a b c), d).

(* Pushing on a buffer. *)

Equations buffer_push {A : Type} {C : color} (x : A) (b : buffer A C) :
  { c : chain A green | chain_seq c = [x] ++ buffer_seq b } :=
buffer_push x B0 := ? Ending (B1 x);
buffer_push x (B1 a) := ? Ending (B2 x a);
buffer_push x (B2 a b) := ? Ending (B3 x a b);
buffer_push x (B3 a b c) := ? Ending (B4 x a b c);
buffer_push x (B4 a b c d) := ? Ending (B5 x a b c d);
buffer_push x (B5 a b c d e) :=
  ? Chain G (Green_node (B3 x a b) Hole (B3 c d e)) (Ending B0).

(* Injecting on a buffer. *)

Equations buffer_inject {A : Type} {C : color} (b : buffer A C) (x : A) :
  { c : chain A green | chain_seq c = buffer_seq b ++ [x] } :=
buffer_inject B0 x := ? Ending (B1 x);
buffer_inject (B1 a) x := ? Ending (B2 a x);
buffer_inject (B2 a b) x := ? Ending (B3 a b x);
buffer_inject (B3 a b c) x := ? Ending (B4 a b c x);
buffer_inject (B4 a b c d) x := ? Ending (B5 a b c d x);
buffer_inject (B5 a b c d e) x :=
  ? Chain G (Green_node (B3 a b c) Hole (B3 d e x)) (Ending B0).

(* Poping from a buffer. *)

Equations buffer_pop {A C} (b : buffer A C) :
  { o : option (A * any_buffer A) |
    buffer_seq b =
    match o with
    | None => []
    | Some (x, b') => [x] ++ any_buffer_seq b'
    end } :=
buffer_pop B0 := ? None;
buffer_pop (B5 a b c d e) := ? Some (a, Any (B4 b c d e));
buffer_pop buf with yellow_pop (Yellowish buf) => { | ? o := ? Some o }.

(* Ejecting from a buffer. *)

Equations buffer_eject {A C} (b : buffer A C) :
  { o : option (any_buffer A * A) |
    buffer_seq b =
    match o with
    | None => []
    | Some (b', x) => any_buffer_seq b' ++ [x]
    end } :=
buffer_eject (B5 a b c d e) := ? Some (Any (B4 a b c d), e);
buffer_eject B0 := ? None;
buffer_eject buf with yellow_eject (Yellowish buf) => { | ? o := ? Some o }.

(* Pushes then ejects. *)

Equations prefix_rot {A C} (x : A) (b : buffer A C) :
  { '(b', y) : buffer A C * A | [x] ++ buffer_seq b = buffer_seq b' ++ [y] } :=
prefix_rot x B0 := ? (B0, x);
prefix_rot x (B1 a) := ? (B1 x, a);
prefix_rot x (B2 a b) := ? (B2 x a, b);
prefix_rot x (B3 a b c) := ? (B3 x a b, c);
prefix_rot x (B4 a b c d) := ? (B4 x a b c, d);
prefix_rot x (B5 a b c d e) := ? (B5 x a b c d, e).

(* Injects then pops. *)

Equations suffix_rot {A C} (b : buffer A C) (y : A) :
  { '(x, b') : A * buffer A C | buffer_seq b ++ [y] = [x] ++ buffer_seq b' } :=
suffix_rot B0 x := ? (x, B0);
suffix_rot (B1 a) x := ? (a, B1 x);
suffix_rot (B2 a b) x := ? (a, B2 b x);
suffix_rot (B3 a b c) x := ? (a, B3 b c x);
suffix_rot (B4 a b c d) x := ? (a, B4 b c d x);
suffix_rot (B5 a b c d e) x := ? (a, B5 b c d e x).

(* Create a green buffer by injecting a pair onto an option. *)

Equations prefix23 {A} (o : option A) (p : A * A) :
  { b : buffer A green | buffer_seq b = option_seq o ++ pair_seq p } :=
prefix23 None (b, c) := ? B2 b c;
prefix23 (Some a) (b, c) := ? B3 a b c.

(* Create a green buffer by poping a pair onto an option. *)

Equations suffix23 {A} (p : A * A) (o : option A) :
  { b : buffer A green | buffer_seq b = pair_seq p ++ option_seq o } :=
suffix23 (a, b) None := ? B2 a b;
suffix23 (a, b) (Some c) := ? B3 a b c.

(* Create a yellow (or green) buffer by pushing an element onto an option. *)

Equations suffix12 {A} (x : A) (o : option A) :
  { b : yellow_buffer A | yellow_buffer_seq b = [x] ++ option_seq o } :=
suffix12 x None := ? Yellowish (B1 x);
suffix12 x (Some y) := ? Yellowish (B2 x y).

(* Returns the decomposed version of a buffer. Here, it is a prefix
   decomposition: when the buffer is overflowed, elements at the end are
   removed. *)

Equations prefix_decompose {A C} (b : buffer A C) :
  { dec : decompose A | buffer_seq b = decompose_main_seq dec ++ decompose_rest_seq dec } :=
prefix_decompose B0 := ? Underflow None;
prefix_decompose (B1 x) := ? Underflow (Some x);
prefix_decompose (B2 a b) := ? Ok (B2 a b);
prefix_decompose (B3 a b c) := ? Ok (B3 a b c);
prefix_decompose (B4 a b c d) := ? Overflow (B2 a b) (c, d);
prefix_decompose (B5 a b c d e) := ? Overflow (B3 a b c) (d, e).

(* Returns the decomposed version of a buffer. Here, it is a suffix
   decomposition: when the buffer is overflowed, elements at the beginning are
   removed. *)

Equations suffix_decompose {A C} (b : buffer A C) :
  { dec : decompose A | buffer_seq b = decompose_rest_seq dec ++ decompose_main_seq dec } :=
suffix_decompose B0 := ? Underflow None;
suffix_decompose (B1 x) := ? Underflow (Some x);
suffix_decompose (B2 a b) := ? Ok (B2 a b);
suffix_decompose (B3 a b c) := ? Ok (B3 a b c);
suffix_decompose (B4 a b c d) := ? Overflow (B2 c d) (a, b);
suffix_decompose (B5 a b c d e) := ? Overflow (B3 c d e) (a, b).

(* Returns the sandwich representation of a buffer. *)

Equations buffer_unsandwich {A C} (b : buffer A C) :
  { sw : sandwich A | buffer_seq b = sandwich_seq sw } :=
buffer_unsandwich B0 := ? Alone None;
buffer_unsandwich (B1 a) := ? Alone (Some a);
buffer_unsandwich (B2 a b) := ? Sandwich a B0 b;
buffer_unsandwich (B3 a b c) := ? Sandwich a (B1 b) c;
buffer_unsandwich (B4 a b c d) := ? Sandwich a (B2 b c) d;
buffer_unsandwich (B5 a b c d e) := ? Sandwich a (B3 b c d) e.

(* Translates a buffer to a pairs buffer. A additional option type is returned
   to handle cases where the buffer contains an odd number of elements. *)

Equations buffer_halve {A C} (b : buffer A C) :
  { '(o, b') : option A * any_buffer (A * A) |
    buffer_seq b = option_seq o ++ flattenp (any_buffer_seq b') } :=
buffer_halve B0 := ? (None, Any B0);
buffer_halve (B1 a) := ? (Some a, Any B0);
buffer_halve (B2 a b) := ? (None, Any (B1 (a, b)));
buffer_halve (B3 a b c) := ? (Some a, Any (B1 (b, c)));
buffer_halve (B4 a b c d) := ? (None, Any (B2 (a, b) (c, d)));
buffer_halve (B5 a b c d e) := ? (Some a, Any (B2 (b, c) (d, e))).

(* Takes any buffer and a pairs green one, and rearranges elements contained in
   the two buffers to return one green buffer and a pairs yellow buffer. The
   order of elements is preserved. *)

Equations green_prefix_concat {A C}
  (buf1 : buffer A C)
  (buf2 : buffer (A * A) green) :
  { '(buf1', buf2') : buffer A green * yellow_buffer (A * A) |
    buffer_seq buf1 ++ flattenp (buffer_seq buf2) =
    buffer_seq buf1' ++ flattenp (yellow_buffer_seq buf2') } :=
green_prefix_concat buf1 buf2 with prefix_decompose buf1 => {
  | (? Ok buf) => ? (buf, Yellowish buf2);
  | (? Underflow opt) with green_pop buf2 => {
    | (? (ab, buf)) =>
        let '(? prefix) := prefix23 opt ab in
        ? (prefix, buf) };
  | (? Overflow buf ab) =>
    let '(? suffix) := green_push ab buf2 in
    ? (buf, suffix)
}.

(* Takes a pairs green buffer and any one, and rearranges elements contained in
   the two buffers to return one pairs yellow buffer and one green buffer. The
   order of elements is preserved. *)

Equations green_suffix_concat {A C}
  (buf1 : buffer (A * A) green)
  (buf2 : buffer A C) :
  { '(buf1', buf2') : yellow_buffer (A * A) * buffer A green |
    flattenp (buffer_seq buf1) ++ buffer_seq buf2 =
    flattenp (yellow_buffer_seq buf1') ++ buffer_seq buf2' } :=
green_suffix_concat buf1 buf2 with suffix_decompose buf2 => {
  | ? Ok buf => ? (Yellowish buf1, buf);
  | ? Underflow opt with green_eject buf1 => {
    | ? (buf, ab) =>
        let '(? suffix) := suffix23 ab opt in
        ? (buf, suffix) };
  | ? Overflow buf ab =>
    let '(? prefix) := green_inject buf1 ab in
    ? (prefix, buf)
}.

(* Takes any buffer and a pairs yellow one, and rearranges elements contained
   in the two buffers to return one green buffer and any pairs buffer. The
   order of elements is preserved. *)

Equations yellow_prefix_concat {A B}
  (buf1 : buffer A B)
  (buf2 : yellow_buffer (A * A)) :
  { '(buf1', buf2') : buffer A green * any_buffer (A * A) |
    buffer_seq buf1 ++ flattenp (yellow_buffer_seq buf2) =
    buffer_seq buf1' ++ flattenp (any_buffer_seq buf2') } :=
yellow_prefix_concat buf1 buf2 with prefix_decompose buf1 => {
  | ? (Ok buf) =>
    let '(Yellowish buf2) := buf2 in
    ? (buf, Any buf2);
  | ? (Underflow opt) with yellow_pop buf2 => {
    | ? (ab, buf) =>
      let '(? prefix) := prefix23 opt ab in
      ? (prefix, buf) };
  | ? (Overflow buf ab) =>
    let '(? suffix) := yellow_push ab buf2 in
    ? (buf, suffix)
}.

(* Takes a pairs yellow buffer and any one, and rearranges elements contained
   in the two buffers to return any pairs buffer and one green buffer. The
   order of elements is preserved. *)

Equations yellow_suffix_concat {A B}
  (buf1 : yellow_buffer (A * A))
  (buf2 : buffer A B) :
  { '(buf1', buf2') : any_buffer (A * A) * buffer A green |
    flattenp (yellow_buffer_seq buf1) ++ buffer_seq buf2 =
    flattenp (any_buffer_seq buf1') ++ buffer_seq buf2' } :=
yellow_suffix_concat buf1 buf2 with suffix_decompose buf2 => {
  | ? (Ok buf) =>
    let '(Yellowish buf1) := buf1 in
    ? (Any buf1, buf);
  | ? (Underflow opt) with yellow_eject buf1 => {
    | ? (buf, ab) =>
      let '(? suffix) := suffix23 ab opt in
      ? (buf, suffix) };
  | ? (Overflow buf ab) =>
    let '(? prefix) := yellow_inject buf1 ab in
    ? (prefix, buf)
}.

(* Creates a green colored deque from three options, one being on a pair. *)

Equations chain_of_opt3 {A}
  (o1 : option A) (o2 : option (A * A)) (o3 : option A) :
  { cd : chain A green |
    chain_seq cd =
      option_seq o1 ++ flattenp (option_seq o2) ++ option_seq o3 } :=
chain_of_opt3 None None None := ? Ending B0;
chain_of_opt3 (Some a) None None := ? Ending (B1 a);
chain_of_opt3 None None (Some a) := ? Ending (B1 a);
chain_of_opt3 (Some a) None (Some b) := ? Ending (B2 a b);
chain_of_opt3 None (Some (a, b)) None := ? Ending (B2 a b);
chain_of_opt3 (Some a) (Some (b, c)) None := ? Ending (B3 a b c);
chain_of_opt3 None (Some (a, b)) (Some c) := ? Ending (B3 a b c);
chain_of_opt3 (Some a) (Some (b, c)) (Some d) := ? Ending (B4 a b c d).

(* A new tactics, flattenp_lists is introduced. It is used when the context contains
   an equality over lists of pairs. The tactic will destruct all the pairs, find
   the hypothesis containing the equality, apply flattenp on it, simplify, and try
   to rewrite it in the goal. *)

Local Ltac flattenp_lists :=
  repeat
  match goal with
  | ab : ?A * ?A |- _ => destruct ab; cbn in *
  end;
  match goal with
  | H : _ ++ [(_, _)] = _ |- _ =>
    apply (f_equal flattenp) in H;
    rewrite !flattenp_app in H;
    cbn in H;
    try aac_rewrite H;
    try aac_rewrite <- H
  | H : [(_, _)] ++ _ = _ |- _ =>
    apply (f_equal flattenp) in H;
    rewrite !flattenp_app in H;
    cbn in H;
    try aac_rewrite H;
    try aac_rewrite <- H
  end.

(* Takes a prefix buffer, a following buffer (when the next level is composed
   of only one buffer), and a suffix buffer. It allows to rearrange all
   elements contained in those buffers into a green cdeque. *)

Equations make_small {A C1 C2 C3}
  (b1 : buffer A C1) (b2 : buffer (A * A) C2) (b3 : buffer A C3) :
  { c : chain A green |
    chain_seq c =
      buffer_seq b1 ++ flattenp (buffer_seq b2) ++ buffer_seq b3 } :=
make_small prefix1 buf suffix1
  with (prefix_decompose prefix1), (suffix_decompose suffix1) => {
    | (? Underflow p1), (? Underflow s1) with buffer_unsandwich buf => {
      | ? Sandwich ab rest cd with prefix23 p1 ab, suffix23 cd s1 => {
        | ? prefix, ? suffix :=
          ? Chain G (Green_node prefix Hole suffix) (Ending rest) };
      | ? Alone opt with chain_of_opt3 p1 opt s1 => { | ? cd := ? cd } };
    | (? Underflow opt), (? Ok s1) with buffer_pop buf => {
      | ? None with opt => {
        | None := ? Ending s1;
        | Some x with buffer_push x s1 => { | ? cd := ? cd } };
      | ? Some (cd, Any rest) with prefix23 opt cd => {
        | ? prefix := ? Chain G (Green_node prefix Hole s1) (Ending rest) } };
    | (? Underflow opt), (? Overflow s1 ab) with suffix_rot buf ab => {
      | ? (cd, center) with prefix23 opt cd => {
        | ? prefix => ? Chain G (Green_node prefix Hole s1) (Ending center) } };
    | (? Ok p1), (? Underflow opt) with buffer_eject buf => {
      | ? None with opt => {
        | None := ? Ending p1;
        | Some x with buffer_inject p1 x => { | ? cd := ? cd } };
      | ? Some (Any rest, cd) with suffix23 cd opt => {
        | ? suffix := ? Chain G (Green_node p1 Hole suffix) (Ending rest) } };
    | (? Ok p1), (? Ok s1) :=
      ? Chain G (Green_node p1 Hole s1) (Ending buf);
    | (? Ok p1), (? Overflow s1 ab) with buffer_inject buf ab => {
      | ? rest => ? Chain G (Green_node p1 Hole s1) rest };
    | (? Overflow p1 ab), (? Underflow opt) with prefix_rot ab buf => {
      | ? (center, cd) with suffix23 cd opt => {
        | ? suffix => ? Chain G (Green_node p1 Hole suffix) (Ending center) } };
    | (? Overflow p1 ab), (? Ok s1) with buffer_push ab buf => {
      | ? rest => ? Chain G (Green_node p1 Hole s1) rest };
    | (? Overflow p1 ab), (? Overflow s1 cd) with buffer_halve buf => {
      | ? (x, Any rest) with suffix12 ab x => {
        | ? Yellowish prefix =>
          ? Chain G (Green_node p1
                    (Yellow_node prefix Hole (B1 cd)) s1) (Ending rest) } } }.
Next Obligation.
  cbn. intros * Hpref1 * Hpref * Hcenter * Hsuff1.
  rewrite Hpref.
  rewrite Hsuff1.
  flattenp_lists.
  hauto db:rlist.
Qed.
Next Obligation.
  cbn. intros * Hpref1 * Hcenter * Hsuff * Hsuff1.
  rewrite Hpref1.
  rewrite Hsuff.
  flattenp_lists.
  hauto db:rlist.
Qed.

(* Takes a red cdeque and returns a green one representing the same set. *)

Equations green_of_red {A : Type} (c : chain A red) :
  { c' : chain A green | chain_seq c' = chain_seq c } :=
green_of_red (Chain R (Red_node p1 Hole s1) (Ending buf))
  with make_small p1 buf s1 => { | ? c' := ? c' };
green_of_red (Chain R (Red_node p1 (Yellow_node p2 child s2) s1) c)
  with yellow_prefix_concat p1 (Yellowish p2),
       yellow_suffix_concat (Yellowish s2) s1 => {
  | ? (p1', Any p2'), ? (Any s2', s1') :=
    ? Chain G (Green_node p1' Hole s1') (Chain R (Red_node p2' child s2') c) };
green_of_red (Chain R (Red_node p1 Hole s1)
             (Chain G (Green_node p2 child s2) c))
  with green_prefix_concat p1 p2, green_suffix_concat s2 s1 => {
  | ? (p1', Yellowish p2'), ? (Yellowish s2', s1') :=
    ? Chain G (Green_node p1' (Yellow_node p2' child s2') s1') c }.
Next Obligation.
  cbn. intros * H1 * H2 *. autorewrite with rlist.
  rewrite !app_assoc H1. hauto db:rlist.
Qed.
Next Obligation.
  cbn. intros * H1 * H2 *. autorewrite with rlist.
  rewrite !app_assoc H1. hauto db:rlist.
Qed.

(* Takes a green or red cdeque, and returns a green one representing
   the same set. *)

Equations ensure_green {A G R} (c : chain A (Mix G NoYellow R)) :
  { c' : chain A green | chain_seq c' = chain_seq c } :=
ensure_green (Ending buf) := ? Ending buf;
ensure_green (Chain G pkt c) := ? Chain G pkt c;
ensure_green (Chain R pkt c) := green_of_red (Chain R pkt c).

(* Takes a yellow packet, as a prefix buffer, a child packet and a suffix
   buffer, and a green or red cdeque. Returns a deque starting with this packet
   and followed by the green version of the input colored deque. *)

Equations make_yellow {A B: Type} {G1 Y1 Y2 G3 Y3 G4 R4}
  (buf1 : buffer A (Mix G1 Y1 NoRed))
  (pkt : packet (A * A) B (Mix NoGreen Y2 NoRed))
  (buf2 : buffer A (Mix G3 Y3 NoRed))
  (c : chain B (Mix G4 NoYellow R4)) :
  { d : deque A |
    deque_seq d = buffer_seq buf1 ++
                  flattenp (packet_seq pkt (chain_seq c)) ++
                  buffer_seq buf2 } :=
make_yellow p1 child s1 c with ensure_green c => {
  | ? c' => ? T (Chain Y (Yellow_node p1 child s1) c') }.

(* Takes a red packet, as a prefix buffer, a child packet and a suffix
   buffer, and a green cdeque. Returns the green version of the colored deque
   made of the red packet followed by the green cdeque. *)

Equations make_red {A B: Type} {C1 Y2 C3}
  (buf1 : buffer A C1)
  (pkt : packet (A * A) B (Mix NoGreen Y2 NoRed))
  (buf2 : buffer A C3)
  (c : chain B green) :
  { d : deque A |
    deque_seq d = buffer_seq buf1 ++
                  flattenp (packet_seq pkt (chain_seq c)) ++
                  buffer_seq buf2 } :=
make_red p1 child s1 cd
  with green_of_red (Chain R (Red_node p1 child s1) cd) => {
    | ? cd' => ? T cd' }.

(* Pushes an element on a deque. *)

Equations push {A: Type} (x : A) (d : deque A) :
  { d' : deque A | deque_seq d' = [x] ++ deque_seq d } :=
push x (T (Ending buf)) with buffer_push x buf => {
  | ? buf' => ? T buf' };
push x (T (Chain G (Green_node p1 child s1) c)) with green_push x p1 => {
  | ? Yellowish buf' with make_yellow buf' child s1 c => {
    | ? d' => ? d' } };
push x (T (Chain Y (Yellow_node p1 child s1) c))
  with yellow_push x (Yellowish p1) => {
  | ? (Any p1') with make_red p1' child s1 c => {
    | ? d' => ? d' } }.

(* Injects an element on a deque. *)

Equations inject {A: Type} (d : deque A) (x : A) :
  { d' : deque A | deque_seq d' = deque_seq d ++ [x] } :=
inject (T (Ending buf)) x with buffer_inject buf x => {
  | ? buf' => ? T buf' };
inject (T (Chain G (Green_node p1 child s1) c)) x with green_inject s1 x => {
  | ? Yellowish buf' with make_yellow p1 child buf' c => {
    | ? d' => ? d' } };
inject (T (Chain Y (Yellow_node p1 child s1) c)) x
  with yellow_inject (Yellowish s1) x => {
  | ? (Any s1') with make_red p1 child s1' c => {
    | ? d' => ? d' } }.

(* Pops an element from a deque. *)

Equations pop {A: Type} (d : deque A) :
  { o : option (A * deque A) |
    deque_seq d = match o with
                  | None => []
                  | Some (x, d') => [x] ++ deque_seq d'
                  end } :=
pop (T (Ending buf)) with buffer_pop buf => {
  pop _ (? None) := ? None;
  pop _ (? Some (x, Any buf')) := ? Some (x, T (Ending buf')) };
pop (T (Chain G (Green_node p1 child s1) c)) with green_pop p1 => {
  | ? (x, Yellowish p1') with make_yellow p1' child s1 c => {
    | ? d' => ? Some (x, d') } };
pop (T (Chain Y (Yellow_node p1 child s1) c))
  with yellow_pop (Yellowish p1) => {
    | ? (x, Any p1') with make_red p1' child s1 c => {
      | ? d' => ? Some (x, d') } }.

(* Ejects an element from a deque. *)

Equations eject {A : Type} (d : deque A) :
  { o : option (deque A * A) |
    deque_seq d = match o with
                  | None => []
                  | Some (d', x) => deque_seq d' ++ [x]
                  end } :=
eject (T (Ending buf)) with buffer_eject buf => {
  eject _ (? None) := ? None;
  eject _ (? Some (Any buf', x)) := ? Some (T (Ending buf'), x) };
eject (T (Chain G (Green_node p1 child s1) c)) with green_eject s1 => {
  | ? (Yellowish s1', x) with make_yellow p1 child s1' c => {
    | ? d' => ? Some (d', x) } };
eject (T (Chain Y (Yellow_node p1 child s1) c))
  with yellow_eject (Yellowish s1) => {
    | ? (Any s1', x) with make_red p1 child s1' c => {
      | ? d' => ? Some (d', x) } }.